---
title: "Strings and Regular Expressions"
author: 
date: 
urlcolor: blue
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true # toc_float option to float the table of contents to the left of the main document content. floating table of contents will always be visible even when the document is scrolled
      #collapsed: false # collapsed (defaults to TRUE) controls whether the TOC appears with only the top-level (e.g., H2) headers. If collapsed initially, the TOC is automatically expanded inline when necessary
      #smooth_scroll: true # smooth_scroll (defaults to TRUE) controls whether page scrolls are animated when TOC items are navigated to via mouse clicks
    number_sections: true
    fig_caption: true # ? this option doesn't seem to be working for figure inserted below outside of r code chunk    
    highlight: tango # Supported styles include "default", "tango", "pygments", "kate", "monochrome", "espresso", "zenburn", and "haddock" (specify null to prevent syntax    
    theme: default # theme specifies the Bootstrap theme to use for the page. Valid themes include default, cerulean, journal, flatly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti.
    df_print: tibble #options: default, tibble, paged

---

# Introduction

## Libraries we will use

Load packages:

```{r, message=FALSE}
library(tidyverse)
library(stringr)  # package for manipulating strings (part of tidyverse)
```

## Dataset we will use

We used `rtweet` to pull Twitter data from the PAC-12 universities. We used the university admissions Twitter handle if there is one, or the main Twitter handle for the university if there isn't one:

```{r}
# library(rtweet)
# 
# p12 <- c("uaadmissions", "FutureSunDevils", "caladmissions", "UCLAAdmission",
#          "futurebuffs", "uoregon", "BeaverVIP", "USCAdmission",
#          "engagestanford", "UtahAdmissions", "UW", "WSUPullman")
# p12_full_df <- search_tweets(paste0("from:", p12, collapse = " OR "), n = 500)
#
# saveRDS(p12_full_df, "p12_dataset.RDS")

# Load previously pulled Twitter data
p12_url <- "https://github.com/anyone-can-cook/rclass2/raw/main/data/recruiting/p12_dataset.RDS"
p12_full_df <- readRDS(url(p12_url, "rb"))

# Use subset of data
p12_df <- p12_full_df %>% select("user_id", "created_at", "screen_name", "text", "location")
head(p12_df)
```


# Lecture overview 

For a review of string basics, see the [first strings lecture](https://anyone-can-cook.github.io/rclass1/lectures/strings_dates_time/strings_dates_time.html).

![](http://a.yu8.us/xkcd-208-regular_expressions.png)

*Credit: Regex Humor ([Rex Egg](https://www.rexegg.com/regex-humor.html))*


In her popular [STAT545 class](https://stat545.com/character-vectors.html#regular-expressions-resources) Jenny Bryan, professor of statistics at University of British Columbia, describes regular expressions (regex) as:

> A God-awful and powerful language for expressing patterns to match in text or for search-and-replace. Frequently described as "write only", because regular expressions are easier to write than to read/understand. And they are not particularly easy to write."

Yes, learning regular expressions is painful. So why are we making you do this? Because regular expressions are a  fundamental building block of data science.

<br>

**An annoying thing people say is that data science is about trying to find the "*signal* in the *noise*"**

- *Noisy data* "is data with a large amount of additional meaningless information in it called noise" ([Wikipedia](https://en.wikipedia.org/wiki/Noisy_data))
- Prior to data science revolution, quant people thought of "data" as something in columns and rows
- The data science revolution is about creating analysis datasets from many pieces of structured, semi-structured, and unstructured data
- But processing all this semi-structured data requires a lot of complex (and often tedious) data manipulation

<br>


**Another annoying thing people say is that "data science is 80% data cleaning and 20% analysis."** 

- Excerpts from a 2014 New York Times article, ["For Big-Data Scientists, 'Janitor Work' Is Key Hurdle to Insights"](https://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html):

> Much handcrafted work — what data scientists call "data wrangling," "data munging" and "data janitor work" — is still required. Data scientists, according to interviews and expert estimates, spend from 50 percent to 80 percent of their time mired in this more mundane labor of collecting and preparing unruly digital data, before it can be explored for useful nuggets.

> "Data wrangling is a huge — and surprisingly so — part of the job," said Monica Rogati, vice president for data science at Jawbone, whose sensor-filled wristband and software track activity, sleep and food consumption, and suggest dietary and health tips based on the numbers. "It’s something that is not appreciated by data civilians. At times, it feels like everything we do."

> "It’s an absolute myth that you can send an algorithm over raw data and have insights pop up," said Jeffrey Heer, a professor of computer science at the University of Washington and a co-founder of Trifacta, a start-up based in San Francisco.

> But if the value [of data science] comes from combining different data sets, so does the headache. Data from sensors, documents, the web and conventional databases all come in different formats. Before a software algorithm can go looking for answers, the data must be cleaned up and converted into a unified form that the algorithm can understand.

> "Practically, because of the diversity of data, you spend a lot of your time being a data janitor, before you can get to the cool, sexy things that got you into the field in the first place," said Matt Mohebbi, a data scientist and co-founder of Iodine.

<br>

**So why learn regular expressions? Because regular expressions are THE preeminent tool for identifying data patterns, and cleaning/transforming "noisy" data**

- Most programmers I speak to talk about regular expressions as one of the most important tools for a programmer to learn
- One could argue that regular expressions are a fundamental driver of the data science revolution, in that they are what made it possible to format and integrate diverse data sources into analysis datasets (I don't know if that is true, but it seems reasonable!)
- For example, web-scraping is fundamentally an application of regular expressions. Grabbing data from the internet is usually very easy. The hard part is processing all that html code into something that can be analyzed.


<br>

# What are regular expressions? 

What are **regular expressions**? ([Geeks for Geeks](https://www.geeksforgeeks.org/write-regular-expressions/))

- **Regular expressions** are an efficient way to match different patterns in strings, similar to the <kbd>ctrl</kbd>+<kbd>f</kbd> or <kbd>cmd</kbd>+<kbd>f</kbd> function you use to find text in a pdf or word document
- For example, regex can be used to match all cases of the exact text `"out-of-state"`. But what makes it so powerful is that we could also have it match different variations or patterns, like `"Out-of-state"`, `"out of state"`, etc.
- In the next subsection, we'll introduce the `str_view()` & `str_view_all()` functions from the `stringr` package (part of `tidyverse`) to help us visualize what is being matched with our regular expressions
    
    ![](https://raw.githubusercontent.com/anyone-can-cook/rclass2/main/assets/images/command_f.png){width=60%}

*Credit: Crystal Han, Ozan Jaquette, & Karina Salazar ([Recruiting the Out-Of-State University](https://emraresearch.org/sites/default/files/2019-03/joyce_report.pdf))*

<br>

## `str_view()` & `str_view_all()`

<style>.str_view { width: inherit !important; }</style>

<br>
__The `str_view()` & `str_view_all()` functions__:

```{r, eval = FALSE}
?str_view
?str_view_all

# SYNTAX AND DEFAULT VALUES
str_view(string, pattern, match = NA)
str_view_all(string, pattern, match = NA)
```

- Function:
  - `str_view()` shows the first match of a regex pattern
  - `str_view_all()` shows all the matches of a regex pattern
- Arguments:
  - `string`: Input vector. Either a character vector, or something coercible to one.
  - `pattern`: Pattern to look for.
      - The default interpretation is a regular expression, as described in `stringi::stringi-search-regex`. Control options with `regex()`.
  - `match`: If `TRUE`, shows only strings that match the pattern. If `FALSE`, shows only the strings that don't match the pattern. Otherwise (the default, `NA`) displays both matches and non-matches.

<br>
**Example**: Using `str_view()` & `str_view_all()` to match literal text

Let's use these functions to match the exact string `"Co"` from one of the tweets in our `p12_df` dataframe. `str_view()` will show us the first pattern match. Notice that the pattern is case-sensitive, as the `"co"` in `"colleagues"` was not matched:

```{r}
str_view(string = p12_df$text[119], pattern = 'Co')
```

<br>
We can use `str_view_all()` to show all matches, not just the first match:

```{r}
str_view_all(string = p12_df$text[119], pattern = 'Co')
```

## Backslash (`\`) escape character

> "A sequence in a string that starts with a `\` is called an **escape sequence** and allows us to include special characters in our strings."

*Credit: [Escape sequences](https://campus.datacamp.com/courses/string-manipulation-with-stringr-in-r/string-basics?ex=4) from DataCamp*

<br>
The **backslash** (`\`) is an escape character, where it makes the character(s) that follow it have special meaning. For example, recall how we can use `\` to escape quotes in a string:

```{r}
my_string <- 'Escaping single quote \' within single quotes'
my_string
```

The alternative would be to create the string using double quotes:

```{r}
my_string <- "Single quote ' within double quotes does not need escaping"
my_string
```

<br>
Similarly, to include a literal backslash in the string, we need to escape the backslash with another backslash:

```{r}
my_string <- "The executable is located in C:\\Program Files\\Git\\bin"
my_string
```

We can use `writeLines()` to see the escaped string:

```{r}
writeLines(my_string)
```

<br>
__The `writeLines()` function__:

```{r, eval = FALSE}
?writeLines

# SYNTAX AND DEFAULT VALUES
writeLines(text, con = stdout(), sep = "\n", useBytes = FALSE)
```

- Function: "`writeLines()` displays quotes and backslashes as they would be read, rather than as R stores them." (From [writeLines](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/writeLines) documentation)
  - When we include **escape sequences** in the string, it is helpful to use `writeLines()` to see how the escaped string looks
  - `writeLines()` will also output the string without showing the outer pair of double quotes that R uses to store it, so we only see the content of the string
- Arguments:
  - `text`: Character vector containing the text you want to display

<br>
The **backslash** (`\`) can also be used to form **special characters**, such as `\n` (newline character) and `\t` (tab character).

These characters following a backslash `\` take on new meaning. For example, the `n` by itself is just a literal `n`. When you add a backslash to `n`, you are making it a special character where `\n` now represents a newline.

```{r}
my_string <- "A\tB\nC\tD"
my_string
```

Use `writeLines()` to see the escaped string:

```{r}
writeLines(my_string)
```

<br>
**Summary**: We can use the backslash (`\`) escape character for:

- `\`: escaping purposes
  - `\'`: literal single quote
  - `\"`: literal double quote
  - `\\`: literal backslash
- `\n`: newline
- `\t`: tab

## Backslashes in regular expressions

> If `\` is used as an escape character in regular expressions, how do you match a literal `\`? Well you need to escape it, creating the regular expression `\\`. To create that regular expression, you need to use a string, which also needs to escape `\`. That means to match a literal `\` you need to write `\\\\` — you need four backslashes to match one!

*Credit: [R for Data Science](https://r4ds.had.co.nz/strings.html#basic-matches) Strings Chapter*

<br>
In regular expressions, the backslash `\` also serves as an escape character, so in order to match a literal `\`, we need to use the regular expression `\\`. For example, let's say we want to match the `\` in the following string:

```{r}
my_string <- "The executable is located in C:\\Program Files\\Git\\bin"

# Use writeLines() to see escaped string
writeLines(my_string)
```

The regular expression we need is `\\`. But this doesn't work:

```{r, eval=FALSE}
# This will give an error if we try to run it
str_view_all(string = my_string, pattern = "\\")
```

Why is that? Let's take a look at what is happening with the string `"\\"` we are providing as the `pattern` argument:

```{r}
# Use writeLines() to see the escaped string
writeLines("\\")
```

As seen, once escaped, the string `"\\"` becomes `\` - so we were providing `\` as the regular expression (i.e., `pattern` argument) instead of the `\\` that we wanted. In order to get `\\`, we need to use the string `"\\\\"`, where the 1st `\` escapes the 2nd and the 3rd `\` escapes the 4th:

```{r}
# Use writeLines() to see the escaped string
writeLines("\\\\")

# This properly matches the `\` in the string
str_view_all(string = my_string, pattern = "\\\\")
```

<br>
**Summary**: Whenever we need to use backslash in our regular expression, we'll need to escape the backslash (by using another backslash) in the string that we provide as the regex `pattern`. For example, to match a newline character `\n` we need to use `"\\n"`, to match a tab character `\t` we need to use `"\\t"`, etc.
<br>



# Regular expression characters {.tabset .tabset-fade .tabset-pills}

Some common **regular expression patterns** include (not inclusive):  

* Character classes
* Quantifiers 
* Anchors  
* Sets and ranges
* Groups and backreferences

*Credit: [DaveChild](https://cheatography.com/davechild/cheat-sheets/regular-expressions/) Regular Expression Cheat Sheet*


**Select each tab**


## Character classes

| STRING  <br>  *(type string that represents regex)* | REGEX <br> *(to have this appear in your regex)* | MATCHES <br> *(to match with this text)* |
|--------------|-----------------|---------|
| `"\\d"`  |    `\d`   |  any digit |
| `"\\D"`  |    `\D`   |  any non-digit|
| `"\\s"`  |    `\s`   |  any whitespace |
| `"\\S"`  |    `\S`   |  any non-whitespace |
| `"\\w"`  |    `\w`   |  any word character |
| `"\\W"`  |    `\W`   |  any non-word character|
| ***Other regex involving backslashes...*** |||
| `"\\n"`  |    `\n`   | newline  |
| `"\\t"`  |    `\t`   | tab |
| `"\\\\"` |    `\\`   | `\`  |
| `"\\."`  |    `\.`    | `.` |
| `"\\?"`  |    `\?`   | `?`  |
| `"\\("`  |    `\(`   | `(` |
| `"\\)"`  |    `\)`   | `)` |
| `"\\{"`  |    `\{`   | `{` |
| `"\\}"`  |    `\}`   | `}` |

*Credit: [Working with strings in stringr](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf) Cheat sheet*

<br>
There are certain **character classes** in regular expression that have special meaning. For example, `\d` is used to match any digit (i.e., _number_), `\s` is used to match any whitespace (i.e., _space, tab, or newline character_), and `\w` is used to match any word character (i.e., _alphanumeric character or underscore_). 

"But wait... there's more! Before a regex is interpreted as a regular expression, it is also interpreted by R as a string. And backslash is used to escape there as well. So, in the end, you need to preprend two backslashes..." This means in R, you would write out the regex patterns as `"\\d"`, `"\\s"`, `"\\w"`, etc.

*Credit: [Escaping sequences](https://stat545.com/character-vectors.html#escaping) from Stat 545*

<br>
<details><summary>**Example**: Using `\d` & `\D` to match digits & non-digits</summary>

We can use `\d` to match all instances of a digit (i.e., _number_):

```{r}
# The escaped string "\\d" results in the regex \d
writeLines("\\d")

# Match any instances of a digit
str_view_all(string = p12_df$text[119], pattern = "\\d")
```

<br>
We can use `\D` to match all instances of a non-digit character:

```{r}
# The escaped string "\\D" results in the regex \D
writeLines("\\D")

# Match any instances of a non-digit
str_view_all(string = p12_df$text[119], pattern = "\\D")
```

<br>
This matches all instances of a digit followed by a non-digit character:

```{r}
str_view_all(string = p12_df$text[119], pattern = "\\d\\D")
```

</details>

<br>
<details><summary>**Example**: Using `\s` & `\S` to match whitespace & non-whitespace</summary>

We can use `\s` to match all instances of a whitespace (i.e., _space, tab, or newline character_):

```{r}
# The escaped string "\\s" results in the regex \s
writeLines("\\s")

# Match any instances of a whitespace
str_view_all(string = p12_df$text[119], pattern = "\\s")
```

<br>
We can use `\S` to match all instances of a non-whitespace character:

```{r}
# The escaped string "\\S" results in the regex \S
writeLines("\\S")

# Match any instances of a non-whitespace
str_view_all(string = p12_df$text[119], pattern = "\\S")
```

<br>
This matches all instances of the letter `e` followed by a whitespace character:

```{r}
str_view_all(string = p12_df$text[39], pattern = "e\\s")
```

</details>

<br>
<details><summary>**Example**: Using `\w` & `\W` to match words & non-words</summary>

We can use `\w` to match all instances of a word character (i.e., _alphanumeric character or underscore_):

```{r}
# The escaped string "\\w" results in the regex \w
writeLines("\\w")

# Match any instances of a word character
str_view_all(string = p12_df$text[119], pattern = "\\w")
```

<br>
We can use `\W` to match all instances of a non-word character:

```{r}
# The escaped string "\\W" results in the regex \W
writeLines("\\W")

# Match any instances of a non-word character
str_view_all(string = p12_df$text[119], pattern = "\\W")
```

<br>
This matches all instances of 3-letter words:

```{r}
str_view_all(string = p12_df$text[119], pattern = "\\W\\w\\w\\w\\W")
```

</details>

<br>
The second half of the table above shows other regular expressions involving backslashes. This includes special characters like `\n` and `\t`, as well as using backslash to escape characters that have special meanings in regex, like `.` or `?` (as we will soon see). So to match a literal period or question mark, we need to use the regex `\.` and `\?`, or strings `"\\."` and `"\\?"` in R.
<br>

***

## Quantifiers


Character  Description   
---------- ------------  
`*`        0 or more       
`?`        0 or 1          
`+`        1 or more       
`{3}`      Exactly 3
`{3,}`     3 or more
`{3,5}`    3, 4, or 5

<br>
We can use **quantifiers** to specify the amount of a certain character or expression to match. The quantifier should directly follow the pattern you want to quantify. For example, `s?` matches 0 or 1 `s` and `\d{4}` matches exactly 4 digits.                   

<br>
<details><summary>**Example**: Using the `*`, `?`, and `+` quantifiers</summary>

We can use `*` to match 0 or more of a pattern:

```{r}
# Matches all instances of `s` followed by 0 or more non-word character
str_view_all(string = p12_df$text[119], pattern = "s\\W*")
```

<br>
We can use `?` to match 0 or 1 of a pattern:

```{r}
# Matches all instances of `s` followed by 0 or 1 non-word character
str_view_all(string = p12_df$text[119], pattern = "s\\W?")
```

<br>
We can use `+` to match 1 or more of a pattern:

```{r}
# Matches all instances of `s` followed by 1 or more non-word character
str_view_all(string = p12_df$text[119], pattern = "s\\W+")

# Matches all hashtags
str_view_all(string = p12_df$text[119], pattern = "#\\w+")
```

</details>


<br>
<details><summary>**Example**: Using `{...}` to specify how many occurrences to match</summary> 

We can use `{n}` to specify the exact number of characters or expressions to match: 

```{r}
# Matches words with exactly 3 letters
str_view_all(string = p12_df$text[119], pattern = "\\s\\w{3}\\s")
```


<br>
We can use `{n,}` to specify `n` as the minimum amount to match: 

```{r}
# Matches words with 3 or more letters
str_view_all(string = p12_df$text[119], pattern = "\\s\\w{3,}\\s")
```

<br>
We can use `{n,m}` to specify we want to match between `n` and `m` amount (inclusive): 

```{r}
# Matches words with between 3 to 5 letters (inclusive)
str_view_all(string = p12_df$text[119], pattern = "\\s\\w{3,5}\\s")
```

</details>
<br>

***  

## Anchors

String     Character  Description     
---------- ---------- ----------------------------------------------------------  
 &nbsp;     `^`       Start of string, or start of line in multi-line pattern         
 &nbsp;     `$`           End of string, or end of line in multi-line pattern    
 `"\\b"`    `\b`                                                Word boundary
 `"\\B"`    `\B`                                            Non-word boundary

 
<br>
We can use **anchors** to indicate which part of the string to match. For example, `^` matches the start of the string, `$` matches the end of the string, `\b` can be used to help detect word boundaries, and `\B` can be used to help match characters within a word.

<br>
<details><summary>**Example**: Using `^` & `$` to match start & end of string</summary> 

We can use `^` to match the start of a string: 

```{r}
# Matches only the quotation mark at the start of the text and not the end quote
str_view_all(string = p12_df$text[119], pattern = '^"')
```


<br>
We can use `$` to match the end of a string: 

```{r}
# Matches only the number at the end of the text and not any other numbers
str_view_all(string = p12_df$text[119], pattern = "\\d$")
```

</details>


<br>
<details><summary>**Example**: Using `\b` & `\B` to match word boundary & non-word boundary</summary> 

We can use `\b` to help detect word boundary: 

```{r}
# Matches words with 3 or more letters using \b
str_view_all(string = p12_df$text[119], pattern = "\\b\\w{3,}\\b")
```

Notice how this is much flexible than trying to use whitespace (`\s`) to determine word boundary:

```{r}
# Matches words with 3 or more letters using \s
str_view_all(string = p12_df$text[119], pattern = "\\s\\w{3,}\\s")
```


<br>
We can use `\B` to help match characters within a word: 

```{r}
# Matches only the letter `s` within a word and not at the start or end
str_view_all(string = p12_df$text[119], pattern = "\\Bs\\B")
```

</details>
<br>

***

## Sets and ranges

Character  Description     
---------- ----------------------------------------------------------
`.`        Match any character except newline (`\n`)
`a|b`      Match `a` or `b`
`[abc]`    Match either `a`, `b`, or `c`
`[^abc]`   Match anything except `a`, `b`, or `c`
`[a-z]`    Match range of lowercase letters from `a` to `z`
`[A-Z]`    Match range of uppercase letters from `A` to `Z`
`[0-9]`    Match range of numbers from `0` to `9`


<br>
The table above lists some more ways regular expression offers us flexibility and option in what we want to match. The period `.` acts as a **wildcard** to match any character except newline. The vertical bar `|` is similar to an **OR** operator. Square brackets `[...]` can be used to specify a set or range of characters to match (or not to match).

<br>
<details><summary>**Example**: Using `.` as a wildcard</summary> 

We can use `.` to match any character except newline (`\n`): 

```{r}
# Matches any character except newline
str_view_all(string = p12_df$text[119], pattern = ".")
```

<br>
We can confirm there is a newline in the tweet above by using `writeLines()`:

```{r}
writeLines(p12_df$text[119])
```

</details>

<br>
<details><summary>**Example**: Using `|` as an OR operator</summary> 

We can use `|` to match either one of multiple patterns: 

```{r}
# Matches `research`, `fight`, or `labs`
str_view_all(string = p12_df$text[119], pattern = "research|fight|labs")

# Matches hashtags or handles
str_view_all(string = p12_df$text[119], pattern = "@\\w+|#\\w+")
```

</details>


<br>
<details><summary>**Example**: Using `[...]` to match (or not match) a set or range of characters</summary> 

We can use `[...]` to match any set of characters: 

```{r}
# Matches hashtags or handles
str_view_all(string = p12_df$text[119], pattern = "[@#]\\w+")

# Matches any 2 consecutive vowels
str_view_all(string = p12_df$text[119], pattern = "[aeiouAEIOU]{2}")
```

<br>
We can also use `[...]` to match any range of alpha or numeric characters: 

```{r}
# Matches only lowercase x through z or uppercase A through C
str_view_all(string = p12_df$text[119], pattern = "[x-zA-C]")

# Matches only numbers 1 through 4 or the pound sign
str_view_all(string = p12_df$text[119], pattern = "[1-4#]")
```

<br>
We can use `[^...]` to indicate we do not want to match the provided set or range of characters:

```{r}
# Matches anything except vowels
str_view_all(string = p12_df$text[119], pattern = "[^aeiouAEIOU]")

# Matches anything that's not uppercase letters
str_view_all(string = p12_df$text[119], pattern = "[^A-Z]+")
```

Notice that `[...]` only matches a single character (see second to last example above). We need to use quantifiers if we want to match a stretch of characters (see last example above).

</details>
<br>

***

## Groups and backreferences

String  Character  Description     
------- ---------- ----------------------------------------------------------
&nbsp;  `(...)`      Capturing group
&nbsp;  `(?:...)`    Non-capturing group
`"\\1"` `\1`         Part of the string matched by capturing group 1
`"\\2"` `\2`         Part of the string matched by capturing group 2
...     ...          ...

<br>
Parentheses can be used to group parts of our regular expression together. Normal parentheses `(...)` creates what is called a numbered **capturing group**. "A capturing group stores the part of the string matched by the part of the regular expression inside the parentheses". For example, if we have `(\d)`, we can refer back to the digit matched by this capturing group using backreferences, like `\1`.

*Credit: Hadley Wickham ([R for Data Science](https://r4ds.had.co.nz/strings.html#grouping-and-backreferences)) Grouping and backreferences*

If we only want to use parentheses for grouping purposes and do not need to reference the matched values, we can use a **non-capturing group** `(?:...)`.

<br>
<details><summary>**Example**: Using capturing groups `(...)` and backreferences</summary> 

We can use capturing groups `(...)` to match certain patterns, then reference what was matched: 

```{r}
# Matches any letter that is repeated 2 times in a row
str_view_all(string = p12_df$text[119], pattern = "([A-Za-z])\\1")

# Matches any string of characters where the first and last letters are the same,
# and the second and least letters are the same
str_view_all(string = p12_df$text[119], pattern = "([a-z])([a-z]).*\\2\\1")
```

</details>

<br>
<details><summary>**Example**: Using non-capturing groups `(?:...)` for grouping purposes</summary> 

We can use non-capturing groups `(?:...)` if we just want to group certain parts of the regex but don't need to reference the matched value: 

```{r}
# Matches one or more of a digit followed by 3 letters
str_view_all(string = p12_df$text[119], pattern = "(?:\\d[A-Za-z]{3})+")
```

<br>
Normal parentheses (capturing groups) can still work for general grouping purposes too. But if you want to group things together without capturing them, you can just use non-capturing groups:

```{r}
# Here, we have 2 capturing groups but only need to reference the 2nd
str_view_all(string = "A1A1A1eeee", pattern = "([A-Z]\\d)+([a-z])\\2{2}")

# So we can just turn the first group into a non-capturing group
str_view_all(string = "A1A1A1eeee", pattern = "(?:[A-Z]\\d)+([a-z])\\1{2}")
```

</details>
<br>

***

# Regex with `stringr` functions

Using regex in `stringr` functions (From [R for Data Science](https://r4ds.had.co.nz/strings.html#other-types-of-pattern))

- When we specify a pattern in a `stringr` function, such as `str_view()`, it is automatically wrapped in a call to `regex()` (i.e., _treated as a regular expression_)

  ```{r}
  # This function call:
  str_view(string = "Turn to page 394...", pattern = "\\d+")
  
  # Is shorthand for:
  str_view(string = "Turn to page 394...", pattern = regex("\\d+"))
  ```
  
- For simplicity, we can omit the call to `regex()`  
- But, there are additional arguments we can supply to `regex()` if we wanted  

  - `regex(pattern, ignore_case = FALSE, multiline = FALSE, comments = FALSE, ...)`  
  - `ignore_case`: If `TRUE`, allows characters to match either their uppercase or lowercase forms  
  - `multiline`: If `TRUE`, allows `^` and `$` to match the start and end of each line rather than the start and end of the complete string  
  - `comments`: If `TRUE`, allows you to use comments and whitespace to make complex regular expressions more understandable  
    - Spaces are ignored, as is everything after `#`  
    - To match a literal space, you’ll need to escape it: `"\\ "`

<br>
<details><summary>**Example**: Specifying `ignore_case = TRUE` in `regex()`</summary>

Let's say we have the following string:

```{r}
s <- "Yay, yay.... YAY!"
s
```

<br>
We can match all the yay's using the following regex:

```{r}
str_view_all(string = s, pattern = "[Yy][Aa][Yy]")
```

<br>
Equivalently, we can specify `ignore_case = TRUE` to avoid dealing with casing variations:

```{r}
str_view_all(string = s, pattern = regex("yay", ignore_case = TRUE))
```

</details>




## `str_detect()`

<br>
__The `str_detect()` function__:

```{r, eval = FALSE}
?str_detect

# SYNTAX AND DEFAULT VALUES
str_detect(string, pattern, negate = FALSE)
```

- Function: Detects the presence or absence of a pattern in a string
  - Returns logical vector (`TRUE` if there is a match, `FALSE` if there is not)
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for
  - `negate`: If set to `TRUE`, the returned logical vector will contain `TRUE` if there is not a match and `FALSE` if there is one

<br>
<details><summary>**Example**: Using `str_detect()` on string</summary>

```{r}
# Detects if there is a digit in the string
str_detect(string = "P. Sherman 42 Wallaby Way", pattern = "\\d")
```

</details>

<br>
<details><summary>**Example**: Using `str_detect()` on character vector</summary>

```{r}
# Detects if there is a digit in each string in the vector
str_detect(string = c("One", "25th", "3000"), pattern = "\\d")
```

</details>

<br>
<details><summary>**Example**: Using `str_detect()` on dataframe column</summary>

Let's create new columns in `p12_df` called `is_am` and `is_pm` that indicates whether or not each tweet's `created_at` time is in the AM or PM, respectively:

```{r}
p12_df %>%
  mutate(
    # Returns `TRUE` if the hour is 0#, 10, or 11, `FALSE` otherwise
    is_am = str_detect(string = created_at, pattern = " 0\\d| 1[01]"),
    # Recall we can set the `negate` argument to switch the returned `TRUE`/`FALSE`
    is_pm = str_detect(string = created_at, pattern = " 0\\d| 1[01]", negate = TRUE)
  ) %>% select(created_at, is_am, is_pm)
```

<br>
Because `TRUE` evaluates to 1 and `FALSE` evaluates to 0 in a numerical context, we could also sum the returned logical vector to see how many of the elements in the vector had a match:

```{r}
# Number of tweets that were created in the AM
num_am_tweets <- sum(str_detect(string = p12_df$created_at, pattern = " 0\\d| 1[01]"))
num_am_tweets
```

<br>
Additionally, we can take the average of the logical vector to get the proportion of elements in the input vector that had a match:

```{r}
# Proportion of tweets that were created in the AM
pct_am_tweets <- mean(str_detect(string = p12_df$created_at, pattern = " 0\\d| 1[01]"))
pct_am_tweets
```

<br>
We can also use the logical vector returned from `str_detect()` to filter `p12_df` to only include rows that had a match:

```{r}
# Keep only rows whose tweet was created in the AM
p12_df %>%
  filter(str_detect(string = created_at, pattern = " 0\\d| 1[01]"))
```

</details>

## `str_subset()`

<br>
__The `str_subset()` function__:

```{r, eval = FALSE}
?str_subset

# SYNTAX AND DEFAULT VALUES
str_subset(string, pattern, negate = FALSE)
```

- Function: Keeps strings that match a pattern
  - Returns input vector filtered to only keep elements that match the specified pattern
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for
  - `negate`: If set to `TRUE`, the returned vector will contain only elements that did not match the specified pattern

<br>
<details><summary>**Example**: Using `str_subset()` on character vector</summary>

```{r}
# Subsets the input vector to only keep elements that contain a digit
str_subset(string = c("One", "25th", "3000"), pattern = "\\d")
```

</details>

<br>
<details><summary>**Example**: Using `str_subset()` on dataframe column</summary>

```{r}
# Subsets the `created_at` vector of `p12_df` to only keep elements that occured in the AM
str_subset(string = p12_df$created_at, pattern = " 0\\d| 1[01]")
```

</details>

## `str_extract()` & `str_extract_all()`

<br>
__The `str_extract()` & `str_extract_all()` functions__:

```{r, eval = FALSE}
?str_extract
?str_extract_all

# SYNTAX AND DEFAULT VALUES
str_extract(string, pattern)
str_extract_all(string, pattern, simplify = FALSE)
```

- Function: Extracts matching patterns from a string
  - Returns first match (`str_extract()`) or all matches (`str_extract_all()`) for input vector
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for
  - `simplify`: If set to `TRUE`, the returned matches will be in a character matrix rather than the default list of character vectors


<br>
<details><summary>**Example**: Using `str_extract()` & `str_extract_all()` on character vector</summary>

**[`str_extract()`]** Extract the first occurrence of a word for each string:

```{r}
# Extracts first match of a word
str_extract(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"),
            pattern = "\\w+")
```

**[`str_extract_all()`]** Extract all occurrences of a word for each string:

```{r}
# Extracts all matches of a word, returning a list of character vectors
str_extract_all(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"), 
                pattern = "\\w+")

# Extracts all matches of a word, returning a character matrix
str_extract_all(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"), 
                pattern = "\\w+", simplify = TRUE)
```

</details>

<br>
<details><summary>**Example**: Using `str_extract()` & `str_extract_all()` on dataframe column</summary>

**[`str_extract()`]** Extract first hashtag:

```{r}
# Extracts first match of a hashtag (if there is one)
p12_df %>% 
  mutate(
    hashtag = str_extract(string = text, pattern = "#\\S+")
  ) %>% select(text, hashtag)
```

**[`str_extract_all()`]** Extract all hashtags:

```{r}
# Extracts all matches of hashtags (if there are any)
p12_df %>% 
  mutate(
    hashtag_vector = str_extract_all(string = text, pattern = "#\\S+"),
    # Use `as.character()` so we can see the content of the character vector of matches
    hashtags = as.character(hashtag_vector)
  ) %>% select(text, hashtag_vector, hashtags)
```

</details>

## `str_match()` & `str_match_all()`

<br>
__The `str_match()` & `str_match_all()` functions__:

```{r, eval = FALSE}
?str_match
?str_match_all

# SYNTAX
str_match(string, pattern)
str_match_all(string, pattern)
```

- Function: Extracts matched groups from a string
  - Returns a character matrix containing the full match in the first column, then additional columns for matches from each capturing group
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for

<br>
<details><summary>**Example**: Using `str_match()` & `str_match_all()` on character vector</summary>

**[`str_match()`]** Extract the first month, day, year for each string:

```{r}
# Extracts first match of month, day, year
str_match(string = c("5-1-2020", "12/25/17", "01.01.13 to 01.01.14"),
          pattern = "(\\d+)[-/\\.](\\d+)[-/\\.](\\d+)")
```

**[`str_match_all()`]** Extract all month, day, year for each string:

```{r}
# Extracts all matches of month, day, year
str_match_all(string = c("5-1-2020", "12/25/17", "01.01.13 to 01.01.14"),
              pattern = "(\\d+)[-/\\.](\\d+)[-/\\.](\\d+)")
```

</details>

<br>
<details><summary>**Example**: Using `str_match()` on dataframe column</summary>

Below, we extract datetime from the `created_at` column. The first capturing group matches the date part and the second capturing group matches the time part:

```{r}
datetime_regex <- "([\\d-]+) ([\\d:]+)"
p12_df %>%
  mutate(
    # The 1st capturing group will be in the 2nd column of the matrix returned from `str_match()`
    # So we use [, 2] below and save the result to the `date` column of the dataframe
    date = str_match(string = created_at, pattern = datetime_regex)[, 2],
    # The 2nd capturing group will be in the 3rd column of the matrix returned from `str_match()`
    # So we use [, 3] below and save the result to the `time` column of the dataframe
    time = str_match(string = created_at, pattern = datetime_regex)[, 3]
  ) %>% select(created_at, date, time)
```

</details>


## `str_replace()` & `str_replace_all()`

<br>
__The `str_replace()` & `str_replace_all()` functions__:

```{r, eval = FALSE}
?str_replace
?str_replace_all

# SYNTAX
str_replace(string, pattern, replacement)
str_replace_all(string, pattern, replacement)
```

- Function: Replaces matched patterns in a string
  - Returns input vector with first match (`str_replace()`) or all matches (`str_replace_all()`) for each string replaced with specified replacement
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for
  - `replacement`: What the matched pattern should be replaced with
- `str_replace_all()` also supports multiple replacements, where you can omit the `replacement` argument and just provide a named vector of replacements as the `pattern`

<br>
<details><summary>**Example**: Using `str_replace()` & `str_replace_all()`</summary>

**[`str_replace()`]** Replace the first occurrence of a vowel:

```{r}
# Replace first vowel with empty string
str_replace(string = "Thanks for the Memories", pattern = "[aeiou]", replacement = "")
```

**[`str_replace_all()`]** Replace all occurrences of a vowel:

```{r}
# Replace all vowels with empty strings
str_replace_all(string = "Thanks for the Memories", pattern = "[aeiou]", replacement = "")
```

</details>

<br>
<details><summary>**Example**: Using backreferences with `str_replace()` & `str_replace_all()`</summary>

**[`str_replace()`]** Reorders the first date that is matched:

```{r}
# Use \\1, \\2, and \\3 to refer to the capturing groups (ie. month, day, year)
str_replace(string = "12/31/19 to 01/01/20", pattern = "(\\d+)/(\\d+)/(\\d+)",
            replacement = "20\\3-\\1-\\2")
```

**[`str_replace_all()`]** Reorders all dates that are matched:

```{r}
# Use \\1, \\2, and \\3 to refer to the capturing groups (ie. month, day, year)
str_replace_all(string = "12/31/19 to 01/01/20", pattern = "(\\d+)/(\\d+)/(\\d+)",
                replacement = "20\\3-\\1-\\2")
```

</details>

<br>
<details><summary>**Example**: Using `str_replace_all()` for multiple replacements</summary>

```{r}
# Replace all occurrences of "at" with "@", and all digits with "#"
str_replace_all(string = "Tomorrow at 10:30AM", pattern = c("at" = "@", "\\d" = "#"))
```

</details>

<br>
<details><summary>**Example**: Using `str_replace_all()` on dataframe column</summary>

```{r}
p12_df %>%
  mutate(
    # Replace all hashtags and handles from tweet with an empty string
    removed_hashtags_handles = str_replace_all(string = text, pattern = "[@#]\\S+", replacement = "")
  ) %>% select(text, removed_hashtags_handles)
```

</details>


## `str_split()`

<br>
__The `str_split()` function__:

```{r, eval = FALSE}
?str_split

# SYNTAX AND DEFAULT VALUES
str_split(string, pattern, n = Inf, simplify = FALSE)
```

- Function: Splits a string by specified pattern
  - Returns character vector containing the split substrings
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for and split by
  - `n`: Maximum number of substrings to return
  - `simplify`: If set to `TRUE`, the returned matches will be in a character matrix rather than the default list of character vectors

<br>
<details><summary>**Example**: Using `str_split()` on character vector</summary>

```{r}
# Split by comma or the word "and"
str_split(string = c("The Lion, the Witch, and the Wardrobe", "Peanut butter and jelly"),
          pattern = ",? and |, ")
```

<br>
We can specify `n` to control the maximum number of substrings we want to return:

```{r}
# Limit split to only return 2 substrings
str_split(string = c("The Lion, the Witch, and the Wardrobe", "Peanut butter and jelly"),
          pattern = ",? and |, ", n = 2)
```

<br>
We can specify `simplify = TRUE` to return a character matrix instead of a list:

```{r}
# Return split substrings in a character matrix
str_split(string = c("The Lion, the Witch, and the Wardrobe", "Peanut butter and jelly"),
          pattern = ",? and |, ", simplify = TRUE)
```

</details>

<br>
<details><summary>**Example**: Using `str_split()` on dataframe column</summary>

When we split the `created_at` field at either a hyphen or space, we can separated out the year, month, day, and time components of the string:

```{r}
p12_df %>%
  mutate(
    # Use `as.character()` so we can see the content of the character vector of splitted strings
    year_month_day_time = as.character(str_split(string = created_at, pattern = "[- ]"))
  ) %>% select(created_at, year_month_day_time)
```

</details>

## `str_count()`

<br>
__The `str_count()` function__:

```{r, eval = FALSE}
?str_count

# SYNTAX AND DEFAULT VALUES
str_count(string, pattern = "")
```

- Function: Counts the number of matches in a string
  - Returns the number of matches
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for

<br>
<details><summary>**Example**: Using `str_count()` on character vector</summary>

```{r}
# Counts the number of digits
str_count(string = c("H2O2", "Year 3000", "4th of July"), pattern = "\\d")
```

</details>

<br>
<details><summary>**Example**: Using `str_count()` on dataframe column</summary>

```{r}
p12_df %>%
  mutate(
    # Counts the total number of hashtags and mentions
    num_hashtags_and_mentions = str_count(string = text, pattern = "[@#]\\S+")
  ) %>% select(text, num_hashtags_and_mentions)
```

</details>


## `str_locate()` & `str_locate_all()`

<br>
__The `str_locate()` & `str_locate_all()` functions__:

```{r, eval = FALSE}
?str_locate
?str_locate_all

# SYNTAX
str_locate(string, pattern)
str_locate_all(string, pattern)
```

- Function: Locates the position of patterns in a string
  - Returns an integer matrix containing the start position of match in the first column and end position of match in second column
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for

<br>
<details><summary>**Example**: Using `str_locate()` & `str_locate_all()` on character vector</summary>

**[`str_locate()`]** Locate the start and end positions for first stretch of numbers:

```{r}
# Locate positions for first stretch of numbers
str_locate(string = c("555.123.4567", "(555) 135-7900 and (555) 246-8000"),
           pattern = "\\d+")
```

**[`str_locate_all()`]** Locate the start and end positions for all stretches of numbers:

```{r}
# Locate positions for all stretches of numbers
str_locate_all(string = c("555.123.4567", "(555) 135-7900 and (555) 246-8000"),
               pattern = "\\d+")
```

</details>

<br>
<details><summary>**Example**: Using `str_locate()` on dataframe column</summary>

```{r}
p12_df %>%
  mutate(
    # Start position of first hashtag in tweet (ie. 1st column of matrix returned from `str_locate()`)
    start_of_first_hashtag = str_locate(string = text, pattern = "#\\S+")[, 1],
    # End position of first hashtag in tweet (ie. 2nd column of matrix returned from `str_locate()`)
    end_of_first_hashtag = str_locate(string = text, pattern = "#\\S+")[, 2],
    # Length of first hashtag in tweet (ie. difference between start and end positions)
    length_of_first_hashtag = end_of_first_hashtag - start_of_first_hashtag
  ) %>% select(text, start_of_first_hashtag, end_of_first_hashtag, length_of_first_hashtag)
```

</details>


# Appendix

## RegExplain Addin  

> Regular expressions are tricky. RegExplain makes it easier to see what you’re doing.

![](https://raw.githubusercontent.com/anyone-can-cook/rclass2/main/assets/images/regexplain.png)

*Credit: Garrick Aden-Buie ([RegExplain](https://www.garrickadenbuie.com/project/regexplain/))*

<br>
**RegExplain** is an RStudio addin that allows the user to check their regex matching functions interactively.

```{r eval=FALSE}
# Installation
devtools::install_github("gadenbuie/regexplain")
library(regexplain)
```

## HTML

__Markup Language__

> "A markup language is a computer language that uses tags to define elements within a document. It is human-readable, meaning markup files contain standard words, rather than typical programming syntax." 

*Credit: [Markup Language](https://techterms.com/definition/markup_language) from TechTerms*

<br>
__Hypertext Markup Language (HTML)__

- HTML is a markup language for the creation of websites
    - HTML puts the content on the webpage, but does not "style" the page (e.g., fonts, colors, background)
    - CSS (**C**ascading **S**tyle **S**heets) adds style to the webpage (e.g., fonts, colors, etc.)
    - Javascript adds functionality to the webpage

### HTML Basics  

__Intro to HTML (and CSS)__

- Watch this __excellent__ 12-minute introductory HTML tutorial by LearnCode.academy
    - Link: [HTML Tutorial for beginners](https://www.youtube.com/watch?v=RjHflb-QgVc)
- Watch this 7-minute introductory CSS tutorial by LearnCode.academy
    - Link: [HTML CSS Tutorial for Beginners](https://youtu.be/J35jug1uHzE)

<br>
__A Simple HTML Document__ (From [w3schools](https://www.w3schools.com/html/html_intro.asp))

- HTML consists of a series of **elements**
  - Elements are defined by a start tag, some content, and an end tag:
    - `<tagname> Content </tagname>`
  - Elements can be nested within one another
- Components of a basic HTML document:
  - Begin with `<!DOCTYPE html>` to indicate it is an HTML document
  - The `<html>` element is the root element of an HTML page, where all other elements are nested
  - The `<head>` element contains meta information about the document (ie. not displayed on webpage)
    - Including CSS style to apply to html content
  - The `<body>` element contains the visible page content

```
<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>
</head>
<body>

<h1>My First Heading</h1>
<p>My first paragraph.</p>

</body>
</html>
```

<br>

### Tags

What are **HTML tags**?

- HTML tags are element names surrounded by angle brackets
- Tags usually come in pairs (e.g. `<p>` and `</p>`)
    - The first tag is the start tag and the second tag is the end tag
- But some tags are self-closing (e.g., `<img />`)
    
*Credit: [HTML introduction](https://www.w3schools.com/html/html_intro.asp) from W3schools*   

<br>
Some **common HTML tags** (_not inclusive_): 

Tag                Description    
------------------ ------------------  
`<h1>` - `<h6>`    Heading     
`<p>`              Paragraph
`<a>`              Link
`<img>`            Image
`<div>`            Division (can think of it as a container to group other elements)
`<strong>`         Bold
`<em>`             Italics
`<ul>`             Unordered list (consists of `<li>` elements)
`<ol>`             Ordered list (consists of `<li>` elements)
&nbsp;&nbsp;`<li>` &nbsp;&nbsp;&nbsp;&nbsp;List item
`<table>`          Table (consists of `<tr>`, `<td>`, & `<th>` elements)
&nbsp;&nbsp;`<tr>` &nbsp;&nbsp;&nbsp;&nbsp;Table row
&nbsp;&nbsp;`<td>` &nbsp;&nbsp;&nbsp;&nbsp;Table data/cell 
&nbsp;&nbsp;`<th>` &nbsp;&nbsp;&nbsp;&nbsp;Table header 

<br>


### Attributes  

What are **attributes**?

- Attributes in HTML elements are optional, but all HTML elements can have attributes
- Attributes are used to specify additional characteristics of elements
- Attributes are __always__ specified in the start tag
- Attributes usually come in name/value pairs like: `name="value"`

*Credit: [HTML attributes](https://www.w3schools.com/html/html_attributes.asp) from W3schools*

<br>
Some **common attributes** you may encounter:

- The `href` attribute for an `<a>` tag (_specifies url to link to_):
  ```
  <a href="https://www.w3schools.com">This is a link</a>
  ```
- The `src` attribute for an `<img>` tag (_specifies image to display_):
  ```
  <img src="html_cheatsheet.jpg" />
  ```
- You can add more than one attribute to an element:
  ```
  <img src="html_cheatsheet.jpg" width="200" height="300" />
  ```
- The `class` and `id` attributes are also commonly added to elements to be able to identify and select for them

<br>

#### `class`  

- The `class` attribute can specify one or more class names for an HTML element
- An element can be identified by its class
- You can select for an element by its class using `.` followed by the class name (more from GeekstoGeeks [here](https://www.geeksforgeeks.org/html-class-attribute/?ref=lbp))
  - For example, this can be used in CSS to select for and style all elements with a specific class

__HTML__:

```{html, eval=FALSE}
<div class="countries">
  <h3>United States</h3>
  <p class="place">Washington D.C.</p>
  <img src="https://cdn.aarp.net/content/dam/aarp/travel/destination-guides/2018/03/1140-trv-dst-dc-main.imgcache.revd66f01d4a19adcecdb09fdacd4471fa8.jpg">
</div>
    
<div class="countries">
  <h3>Mexico</h3>
  <p class="place">Guadalajara</p>
  <img src="https://cityofguadalajara.com/wp-content/uploads/2016/11/Centro-Historico-de-Guadalajara-800x288.jpg">
</div>
```
 
__CSS__:
 
```{css, eval=FALSE}
<style>   
.countries {
  background-color: #e6e6e6;
  color: #336699;
  margin: 10px;
  padding: 15px;
}

.place {
  color: black;
}
</style>
```

__Result__:

<style>
.countries {
  background-color: #e6e6e6;
  color: #336699;
  margin: 10px;
  padding: 15px;
  display: inline-block;
}

.place {
  color: black;
}

.countries img {
  width: 200px;
  height: 100px;
  overflow: hidden;
}
</style>

<div class="countries">
<h3>United States</h3>
<p class="place">Washington D.C </p>
<img src="https://cdn.aarp.net/content/dam/aarp/travel/destination-guides/2018/03/1140-trv-dst-dc-main.imgcache.revd66f01d4a19adcecdb09fdacd4471fa8.jpg">
</div>


<div class="countries">
<h3>Mexico</h3>
<p class="place">Guadalajara</p>
<img src="https://cityofguadalajara.com/wp-content/uploads/2016/11/Centro-Historico-de-Guadalajara-800x288.jpg">
</div>

*Credit: [HTML Classes](https://www.w3schools.com/html/html_classes.asp) from W3schools*


#### `id`

- The `id` attribute is used to specify one unique HTML element within the HTML document
- An element can be identified by its id
- You can select for an element by its id using `#` followed by the id name (more from GeekstoGeeks [here](https://www.w3schools.com/html/html_id.asp))
  - For example, this can be used in CSS to select for and style a specific element with a certain id

__HTML__:

```{html, eval=FALSE}
<div id="banner">My Banner</div>
```

__CSS__:

```{css, eval=FALSE}
<style>
#banner {
  background-color: #e6e6e6;
  font-size: 40px;
  padding: 20px;
  text-align: center;
}
</style>
```

__Result__:

<style>
#banner {
  background-color: #e6e6e6;
  font-size: 40px;
  padding: 20px;
  text-align: center;
}
</style>

<div id="banner">My Banner</div>

*Credit: [HTML Id](https://www.w3schools.com/html/html_id.asp) from W3schools*


<br>

### Student Exercise

- Spend 5-10 minutes playing with the simple HTML text below; experiment with whichever additional elements/tags/attributes/etc you want
- Paste the below code into [TryIt Editor](https://www.w3schools.com/html/tryit.asp?filename=tryhtml_default) and click __Run__

```{html, eval=FALSE}
<!DOCTYPE html>
<html>
<head>
  <title>Page title (in head tag)</title>
</head>
<body>

  <h1>Title of level 1 heading</h1>
  
  <p>My first paragraph.</p>
  <p>My second paragraph.</p>
  <p>Add some bold text <strong>right here</strong></p>
  <p>Add some italics text <em>right here</em></p>
  

  <p>Include a hyperlink tag within a paragraph tag. this book looks interesting : <a href="https://bookdown.org/rdpeng/rprogdatascience/">R Programming for Data Science</a></p>  
  
  <p>Include another hyperlink tag within a paragraph tag. chapter on <a href="https://bookdown.org/rdpeng/rprogdatascience/regular-expressions.html">Regular Expressions</a></p>    
  <p> put a button inside this paragraph <button>I am a button!</button></p>
  
  <p>Here are some items in a list, but items not placed within an unordered list </p>
  
  <li> text you want in item</li>
  <li> text you want in another item</li>
  
  <p>Here are some items in an unordered list</p>
  
  <ul>
  <li> first item in unordered list </li>
  <li> second item in unordered list </li>
  </ul>

</body>
  
</html>
```

<br>

### HTML Resources

Lots of wonderful resources on the web to learn HTML!

- Use this website to create/modify HTML code and view the result after it is compiled
    - [TryIt Editor](https://www.w3schools.com/html/tryit.asp?filename=tryhtml_default)
- HTML cheat sheets 
    - [Link to HTML cheat sheet (PDF)](https://web.stanford.edu/group/csp/cs21/htmlcheatsheet.pdf)
    - [Link to another HTML cheat sheet ](http://www.cheat-sheets.org/saved-copy/html-cheat-sheet.png), (shown below) 


![](http://www.cheat-sheets.org/saved-copy/html-cheat-sheet.png)

## Webscraping using `rvest`

__The `rvest` package__

> `rvest` helps you scrape information from web pages. It is designed to work with magrittr to make it easy to express common web scraping tasks, inspired by libraries like beautiful soup.

*Credit: `rvest` [webpage](http://rvest.tidyverse.org/)*

> [`rvest` package contains] Wrappers around the `xml2` and `httr` packages to make it easy to download, then manipulate, HTML and XML.

*Credit: `rvest` package documentation*

<br>

```{r, warning=F, message=F}
library(rvest)
```

<br>
__Why use the `rvest` package?__

- `rvest` makes it easy to parse HTML
- First, we use the `read_html()` function to [read in the HTML](#reading-html) and convert it to an `xml_document`/`xml_node` object
- A **node** is just an HTML **element**
- HTML is made up of nested elements, so once we've read in the HTML to a `xml_node` object, we can easily traverse the nested nodes (ie. children elements) and [parse the HTML](#parsing-html)
- `rvest` comes with many helpful functions to search and extract various parts of the HTML
  - `html_node()`/`html_nodes()`: Search and extract node(s) (ie. HTML elements)
  - `html_text()`: Extract the content between HTML tags
  - `html_attr()`/`html_attrs()`: Extract the attribute(s) of HTML tags


### Reading HTML

__The `read_html()` function__:

```{r, eval = FALSE}
?read_html

# SYNTAX AND DEFAULT VALUES
read_html(x, encoding = "", ..., options = c("RECOVER", "NOERROR", "NOBLANKS"))
```

- Arguments:
  - `x`: The input can be a string containing HTML or url to the webpage you want to scrape
- Output:
  - The HTML that is read in will be returned as an `rvest` `xml_document`/`xml_node` object and can be easily parsed
  - You can also view the raw HTML using `as.character()`
  
__Scraping HTML from a webpage__:

- Navigate to the webpage (e.g., https://corona.help/) in your browser
  - If possible, use Google Chrome or Mozilla Firefox
- View the HTML of the page by right clicking > `View Page Source`
  - This will be the raw HTML that is scraped when we use `read_html()`
- When you right click, you may notice another option called `Inspect` (Chrome) or `Inspect Element` (Firefox) that will pop up a side panel
  - This can be helpful for visualizing the HTML elements on the page
  - You can also click on this side panel and hit <kbd>ctrl</kbd> + <kbd>f</kbd> (Windows) or <kbd>cmd</kbd> + <kbd>f</kbd> (Macs) to search for elements using a selector
  - But note that the HTML you see here might not be the same as what you see in `View Page Source` (i.e., _what is scraped_), since it also reflects changes made to the HTML _after_ the page was loaded (e.g., _by JavaScript_)

<br>
<details><summary>**Example**: Using `read_html()` to read in HTML from string</summary>

```{r}
html <- read_html("<h1>This is a heading.</h1><p>This is a paragraph.</p>")

# View object
html

# View class of object
class(html)

# View raw HTML
as.character(html)
```

</details>

<br>
<details><summary>**Example**: Using `read_html()` to scrape the page `https://corona.help/`</summary>


```{r}
corona <- read_html("https://corona.help/")

# View object
corona

# View class of object
class(corona)
```

```{r, eval=FALSE}
# View raw HTML [output omitted]
as.character(corona)
```

```{r}
# Inspect raw HTML
str(as.character(corona))
```

</details>

### Parsing HTML

__The `html_node()` & `html_nodes()` functions__:

```{r, eval = FALSE}
?html_node
?html_nodes

# SYNTAX
html_node(x, css, xpath)
html_nodes(x, css, xpath)
```

- Arguments:
  - `x`: An `rvest` `xml_document`/`xml_node` object (use `read_html()` to get this)
  - `css`: Selector (can select by HTML tag name, its attributes, etc.)
- Output:
  - `html_node()` returns the first element that it finds as an `rvest` `xml_node` object
    - Recall that a node is just an HTML element
  - `html_nodes()` returns all elements that it finds as an `rvest` `xml_nodeset` object
    - All elements that are selected will be returned in a nodeset
  - Again, you can view the raw HTML using `as.character()`
    - Syntax: `as.character(html_node(...))`

__Selecting for HTML elements__:

- HTML elements can be selected in many ways
  - Selecting by tagname: `'p'`, `'table'`, etc.
  - Selecting by class using `.`: `'.my-class'`
  - Selecting by id using `#`: `'#my-id'`
  - Selecting nested elements: `'table tr'` (_selects all rows within a table_)
- You can test your selector in your browser
  - Right click and select `Inspect` (Chrome) or `Inspect Element` (Firefox) to bring up a side panel
  - Hit <kbd>ctrl</kbd> + <kbd>f</kbd> (Windows) or <kbd>cmd</kbd> + <kbd>f</kbd> (Macs) and enter your selector to search for elements


<br>
<details><summary>**Example**: Using `html_node()` & `html_nodes()` to parse HTML string</summary>

Remember that the input to `html_node()`/`html_nodes()` should be an `rvest` `xml_document`/`xml_node` object, which we can obtain from `read_html()`:

```{r}
html <- read_html("<p>Paragraph #1</p><p>Paragraph #2</p><p>Paragraph #3</p>")

# View class of object
class(html)

# View raw HTML to see what elements are there
as.character(html)
```

<br>
If we search for the `<p>` element using `html_node()`, it will return the first result:

```{r}
first_p <- html_node(html, 'p')

# View class of object
class(first_p)

# View raw HTML
as.character(first_p)
```

<br>
If we search for the `<p>` element using `html_nodes()`, it will return all results:

```{r}
all_p <- html_nodes(html, 'p')

# View class of object
class(all_p)

# View raw HTML
as.character(all_p)
```

<br>
Note that we could also use `%>%`:

```{r}
# These are equivalent to the above
first_p <- html %>% html_node('p')
all_p <- html %>% html_nodes('p')
```

</details>


<br>
<details><summary>**Example**: Using `html_node()` & `html_nodes()` to parse `https://corona.help/`</summary>


Let's revisit the HTML we scraped from https://corona.help/ in the previous example

  - We will try selecting for the "Total by country" table off of that page
  - In your browser, right click > `View Page Source` to check that the `table` element is indeed in the scraped HTML
  - Then, you can right click the table on the page and inspect it to better visualize the elements


```{r}
# Scraped HTML is stored in this `xml_document`/`xml_node` object
class(corona)
```

<br>
Select for the `<table>` element on that page using `html_node()`:

```{r}
# Since this table is the only table on the page, we can just use `html_node()`
corona_table <- corona %>% html_node('table')
corona_table

# View class of object
class(corona_table)
```

```{r, eval=FALSE}
# View raw HTML of `corona_table` [output omitted]
as.character(corona_table)
```

<br>
Select all rows in the table (i.e., `<tr>` elements) using `html_nodes()`

- It makes sense to select by row (rather than column) because each row usually represent an observation
- The way HTML tables are structured also makes it easier to extract information by row because each `<tr>` element (i.e., row) has `<th>`/`<td>` elements (i.e., column cells) nested within it, and not the other way around
- But if you wanted to select a certain column, there are ways to do that as well (e.g., `table tr td:nth-child(1)` selects the first cell in each row a.k.a. the first column in table)


```{r}
# We can chain `html_node()`/`html_nodes()` functions
corona_rows <- corona %>% html_node('table') %>% html_nodes('tr')

# Alternatively, we can use `table tr` as the selector to select all `tr` elements within a `table`
corona_rows <- corona %>% html_nodes('table tr')

# Investigate object
head(corona_rows) # View first few rows
typeof(corona_rows)
class(corona_rows)
length(corona_rows) # Number of elements
```

</details>

<br>

### Practicing regex

The following examples use the Coronavirus data from https://corona.help/

  - Recall that we have selected for all rows in the data table on that page in the previous example
  - If we wanted to try and create a dataframe out of this table, we could further select each cell in the table (i.e., `<td>` elements from each row)
  - For now, we will be practicing parsing data from each row using regex

View `corona_rows` we selected from previous example:

```{r}
# View first few rows
head(corona_rows)
corona_rows[1:5] # first five rows
corona_rows[c(1)] # header row
corona_rows[1] # header row
```

<br>
Let's convert this to raw HTML using `as.character()` to practice writing regular expressions. Refer back to this output to help you determine what pattern you want to match:

```{r}
# Convert rows to raw HTML
rows <- as.character(corona_rows)[-c(1)] # [-c(1)] means skip header row

# View first few rows as raw HTML
writeLines(head(rows, 2))  # printing via writeLines() is much prettier than printing via print()

# Investgate object named `rows`, which is a character vector
typeof(rows)
class(rows)
length(rows)
```

<br>
<details><summary>**Example**: Using `str_subset()` to subset rows</summary>

Let's filter for rows whose country name starts with `'United'`. First, preview what our regular expression matches using `str_view()`:

```{r}
str_view_all(string = head(rows), pattern = 'United \\w+')
```


Inspect the output from `str_detect()`, which returns `TRUE` if there is a match and `FALSE` if not. For example, we see there is a `TRUE` for the first element (United States) and fifth element (United Kingdom):

```{r}
str_detect(string = head(rows), pattern = 'United \\w+')
```

Finally, subset rows by country name using `str_subset()`, which keeps elements of character vector for which `str_detect()` is `TRUE` (i.e., keeps elements where the pattern "matches"):

```{r}
subset_by_country <- str_subset(string = rows, pattern = 'United \\w+')
writeLines(subset_by_country)
```


</details>

<br>
<details><summary>**Example**: Using `str_extract()` to extract link for each row</summary>

Since all links follow the same pattern, we can use regex to extract this info:

```{r}
links <- str_extract(string = rows, pattern = 'https://corona.help/country/[-a-z]+')

# View first few links
head(links)
```

</details>

<br>
<details><summary>**Example**: Using `str_match()` to extract country for each row</summary>

Since all countries are in a `div` element with the same attributes, we can use the following regex to extract the country name:

```{r}
countries <- str_match(string = rows, pattern = '<div style="height:100%;width:100%">([\\w ]+)</div>')

# View first few countries
# We used a capturing group to extract the country name from between the tags
head(countries)
```

</details>

<br>
<details><summary>**Example**: Using `str_match_all()` to extract number deaths and critical for each row</summary>

Since both the number of deaths and critical are in a `<td>` element with the same `class` attribute, we can use the following regex to extract both numbers:

```{r}
num_danger <- str_match_all(string = rows, pattern = '<td class="text-danger">([\\d,]+)</td>')

# View matches for first few rows
# We used a capturing group to extract the numbers from between the tags
head(num_danger)
```

</details>

<br>
<details><summary>**Example**: Using `str_replace_all()` to convert numeric values to thousands for each row</summary>

Rewrite all numeric values greater than one thousand in terms of `k`:

```{r}
num_to_k <- str_replace_all(string = rows, pattern = '>([\\d,]+),\\d{3}<', replacement = '>\\1k<')

# View replacements for first few rows
writeLines(head(num_to_k))
```

</details>
