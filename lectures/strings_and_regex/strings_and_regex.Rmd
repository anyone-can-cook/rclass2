---
title: "Strings and Regular Expressions"
author: 
date: 
urlcolor: blue
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true # toc_float option to float the table of contents to the left of the main document content. floating table of contents will always be visible even when the document is scrolled
      #collapsed: false # collapsed (defaults to TRUE) controls whether the TOC appears with only the top-level (e.g., H2) headers. If collapsed initially, the TOC is automatically expanded inline when necessary
      #smooth_scroll: true # smooth_scroll (defaults to TRUE) controls whether page scrolls are animated when TOC items are navigated to via mouse clicks
    number_sections: true
    fig_caption: true # ? this option doesn't seem to be working for figure inserted below outside of r code chunk    
    highlight: tango # Supported styles include "default", "tango", "pygments", "kate", "monochrome", "espresso", "zenburn", and "haddock" (specify null to prevent syntax    
    theme: default # theme specifies the Bootstrap theme to use for the page. Valid themes include default, cerulean, journal, flatly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti.
    df_print: tibble #options: default, tibble, paged
bibliography: ../../assets/bib/educ260b_bib.bib
csl: ../../assets/bib/apa.csl
---

```{r, echo=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", highlight = TRUE)
```

# Introduction

## Libraries we will use

Load packages:

```{r, message=FALSE}
library(tidyverse)
library(stringr)  # package for manipulating strings (part of tidyverse)
library(rtweet)
```
```{r}
getwd()
```

## Dataset we will use

We used the `rtweet` package to pull Twitter data from the PAC-12 universities. Specifically, we used the university's admissions Twitter handle if there was one, or the main Twitter handle for the university if there wasn't one:

```{r}
# p12 <- c("uaadmissions", "FutureSunDevils", "caladmissions", "UCLAAdmission",
#          "futurebuffs", "uoregon", "BeaverVIP", "USCAdmission",
#          "engagestanford", "UtahAdmissions", "UW", "WSUPullman")
# p12_full_df <- search_tweets(paste0("from:", p12, collapse = " OR "), n = 500)
#
# saveRDS(p12_full_df, "p12_dataset.RDS")

# Load previously pulled Twitter data
p12_url <- "https://github.com/anyone-can-cook/rclass2/raw/main/data/recruiting/p12_dataset.RDS"
p12_full_df <- readRDS(url(p12_url, "rb"))

# Use subset of data
p12_df <- p12_full_df %>% select("user_id", "created_at", "screen_name", "text", "location")
head(p12_df)
```

## Cheat sheets

Here are two useful **cheat sheets** about working with strings and regular expressions

- [stringr package and regular expressions](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)
  - Two pages, assumes _R_ programming language; first page = functions from stringr package; second page = regular expressions
- [regular expressions cheat sheet](https://cheatography.com/davechild/cheat-sheets/regular-expressions/pdf/)
  - One page; just focuses on regular expressions, which are used across programming languages

__Print these cheat sheets. Make one of them  your "go to" cheat sheet.__


## Lecture overview 


![](http://a.yu8.us/xkcd-208-regular_expressions.png)

*Credit: Regex Humor ([Rex Egg](https://www.rexegg.com/regex-humor.html))*

In [rclass1](https://anyone-can-cook.github.io/rclass1/), we introduced strings and some basic functions for working with strings.

- For a review of string basics, see the [first strings lecture](https://anyone-can-cook.github.io/rclass1/lectures/strings_dates_time/strings_dates_time.html).

In [rclass2](https://anyone-can-cook.github.io/rclass2/), this "Strings and Regular Expressions" lecture provides deeper knowledge about strings, string functions, and -- most importantly -- regular expressions. 

- This lecture focuses mostly on regular expressions because regular expressions are the most useful tool for working with strings and also the most difficult to learn.

<br>

What are **regular expressions**? ([Geeks for Geeks](https://www.geeksforgeeks.org/write-regular-expressions/))

- **Regular expressions** are an efficient way to match different patterns in strings, similar to the <kbd>ctrl</kbd>+<kbd>f</kbd> or <kbd>cmd</kbd>+<kbd>f</kbd> function you use to find text in a pdf or word document
- For example, regex can be used to match all cases of the exact text `"out-of-state"`. But what makes it so powerful is that we could also have it match different variations or patterns, like `"Out-of-state"`, `"out of state"`, etc.

    
    ![](https://raw.githubusercontent.com/anyone-can-cook/rclass2/main/assets/images/command_f.png){width=60%}

*Credit: Crystal Han, Ozan Jaquette, & Karina Salazar ([Recruiting the Out-Of-State University](https://emraresearch.org/sites/default/files/2019-03/joyce_report.pdf))*

<br>


In her popular [STAT545 class](https://stat545.com/character-vectors.html#regular-expressions-resources) Jenny Bryan, professor of statistics at University of British Columbia, describes regular expressions (regex) as:

> A God-awful and powerful language for expressing patterns to match in text or for search-and-replace. Frequently described as "write only", because regular expressions are easier to write than to read/understand. And they are not particularly easy to write."

Yes, learning regular expressions is painful. So why are we making you do this? Because regular expressions are a  fundamental building block of data science.

<br>
<br>

**A thing people say is that data science is about trying to find the "*signal* in the *noise*"**

- *Noisy data* "is data with a large amount of additional meaningless information in it called noise" ([Wikipedia](https://en.wikipedia.org/wiki/Noisy_data))
- Prior to data science revolution, quant people thought of "data" as something in columns and rows
- The data science revolution is about creating analysis datasets from many pieces of structured, semi-structured, and unstructured data
- But processing all this semi-structured data requires a lot of complex (and often tedious) data manipulation

<br>


**Another thing people say is that "data science is 80% data cleaning and 20% analysis."** 

- Excerpts from a 2014 New York Times article, ["For Big-Data Scientists, 'Janitor Work' Is Key Hurdle to Insights"](https://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html):

> Much handcrafted work — what data scientists call "data wrangling," and "data munging" — is still required. Data scientists, according to interviews and expert estimates, spend from 50 percent to 80 percent of their time mired in this more mundane labor of collecting and preparing unruly digital data, before it can be explored for useful nuggets.

> "Data wrangling is a huge — and surprisingly so — part of the job," said Monica Rogati, vice president for data science at Jawbone, whose sensor-filled wristband and software track activity, sleep and food consumption, and suggest dietary and health tips based on the numbers. "It’s something that is not appreciated by data civilians. At times, it feels like everything we do."

> "It’s an absolute myth that you can send an algorithm over raw data and have insights pop up," said Jeffrey Heer, a professor of computer science at the University of Washington and a co-founder of Trifacta, a start-up based in San Francisco.

> But if the value [of data science] comes from combining different data sets, so does the headache. Data from sensors, documents, the web and conventional databases all come in different formats. Before a software algorithm can go looking for answers, the data must be cleaned up and converted into a unified form that the algorithm can understand.

<br>

**So why learn regular expressions? Because regular expressions are THE preeminent tool for identifying data patterns, and cleaning/transforming "noisy" data**

- Most programmers I speak to talk about regular expressions as one of the most important tools for a programmer to learn
- One could argue that regular expressions are a fundamental driver of the data science revolution, in that they are what made it possible to format and integrate diverse data sources into analysis datasets (I don't know if that is true, but it seems reasonable!)
- For example, web-scraping is fundamentally an application of regular expressions. Grabbing data from the internet is usually very easy. The hard part is processing all that html code into something that can be analyzed.


<br>

# Prerequisites to regex

This section introduces some prerequisite functions and concepts that will help us learn regular expressions.


## `str_view()` and `str_view_all()`

We introduce the `str_view()` & `str_view_all()` functions from the `stringr` package (part of `tidyverse`) to help us visualize what is being matched with our regular expressions

<style>.str_view { width: inherit !important; }</style>

<br>
__The `str_view()` & `str_view_all()` functions__:

```{r, eval = FALSE}
?str_view
?str_view_all

# SYNTAX AND DEFAULT VALUES
str_view(string, pattern, match = NA)
str_view_all(string, pattern, match = NA)
```

- Function:
  - `str_view()` shows the first match of a regex pattern
  - `str_view_all()` shows all the matches of a regex pattern
- Arguments:
  - `string`: Input vector. Either a character vector, or something coercible to one.
  - `pattern`: Pattern to look for.
      - The default interpretation is a regular expression, as described in `stringi::stringi-search-regex`. Control options with `regex()`.
  - `match`: If `TRUE`, shows only strings that match the pattern. If `FALSE`, shows only the strings that don't match the pattern. Otherwise (the default, `NA`) displays both matches and non-matches.

<br>
**Example**: Using `str_view()` & `str_view_all()` to match literal text

We'll match text from this string vector:
```{r}
#p12_df$text[119]
writeLines(p12_df$text[119])

p12_df$text[119] %>% length() # our string has length==1 (i.e., it is a one-element character vector)
```


Let's use these functions to match the exact string `"Co"` from one of the tweets in our `p12_df` dataframe. `str_view()` will show us the first pattern match. Notice that the pattern is case-sensitive, as the `"co"` in `"colleagues"` was not matched:

```{r}
str_view(string = p12_df$text[119], pattern = 'Co')
```

<br>
We can use `str_view_all()` to show all matches, not just the first match:

```{r}
str_view_all(string = p12_df$text[119], pattern = 'Co')
```

We can also apply `str_view()` and `str_view_all()` to vectors with more than one element:

```{r}
p12_df$text[119] %>% length() # one element
p12_df$text %>% length() # many elements
```

When applying `str_view()` to a character vector with more then one element, `str_view()` shows us the first pattern match for each element (output omitted):

```{r, eval = FALSE}
str_view(string = p12_df$text, pattern = 'Co')
```

When applying `str_view_all()` to a character vector with more then one element, `str_view_all()` shows all pattern matches for each element (output omitted):

```{r, eval = FALSE}
str_view_all(string = p12_df$text, pattern = 'Co')
```


## Special characters and (`\`) escape

The concepts **special characters** and **escape sequence** are essential for a deeper understanding of strings and for working with regular expressions. But these concepts are tricky to get your head around, in part because you cannot understand one concept without understanding the other.

__Special characters__

The literal definition of special characters are characters that are not alphanumeric characters (e.g., `\`,`?`, `(`)

But usually, when the programming world talks about special characters in relation to working with strings, special characters are defined as:

- A character or sequence of characters that will not be interpreted literally because they have a special meaning (e.g., they represent some symbol or some function)

For example, here are two common special characters

- `\n` represents a new line
- `\t` represents a tab

These characters followed by a backslash `\` take on a new meaning. The `n` by itself is just an `n`. When you add a backslash to the `\n` you are "escaping it" and making it a special character where `\n` now represents a newline.


```{r}
x <- "Hi!\nMy name is\nWhat?\nMy name is\nWho?\nMy name is\nChika-chika\nSlim Shady"

# note that print(x) prints the literal text, not its special meaning
print(x) # print 

# wrapping print(x) within writeLInes() prints text after executing special meaning
writeLines(x)
```

__Escape sequences__

Definition of escape sequence

- From [DataCamp](https://campus.datacamp.com/courses/string-manipulation-with-stringr-in-r/string-basics?ex=4)
  - "A sequence in a string that starts with a `\` is called an **escape sequence** and allows us to include special characters in our strings."
- From [Wikipedia](https://en.wikipedia.org/wiki/Escape_sequences_in_C)
  - "An escape sequence is a sequence of characters that does not represent itself when used inside a character or string literal, but is translated into another character or a sequence of characters that may be difficult or impossible to represent directly"

<br>

This [Wikipedia quote] about the _C_ programming language is also true for _R_ and most other programming languages:

> In C, all escape sequences consist of two or more characters, the first of which is the backslash, `\` (called the "Escape character"); the remaining characters determine the interpretation of the escape sequence. For example, `\n` is an escape sequence that denotes a newline character


Usually, we use the backslash (`\`) escape character for one of two broad purposes:

1. To enable our string to include a literal character that would otherwise be interpreted by the programming language as a special character (e.g., to include a quote character in our string)
1. To include a special character in our string (e.g., using `\n` in our string to insert a newline character in our string)

<br>

__Using backslash escape character (`\`) to enable our string to include a literal character that would otherwise be interpreted by the programming language as a special character__


**Example**: What if we wanted to include quote characters (e.g., single quote `'`, or double quote `"`) in our string

- If we enclose our string using single quotation marks `'`, we cannot insert a single quotation mark within the string (code not run):

```{r, eval = FALSE}
x <- 'I am trying to include a single quote ' within my string'
x
```

- Similarly, if we enclose our string using double quotation marks `"`, we cannot insert a double quotation mark within the string (code not run):

```{r, eval = FALSE}
x <- "I am trying to include a double quote " within my string"
x
```

**Solution**, without using backslash (`\`) escape character

- If we want to include a single quote `'` in our string, then enclose the entire string using double quotes `"`:

```{r}
x <- "I am trying to include a single quote ' within my string"
writeLines(x)
```

- If we want to include a double quote `"` in our string, then enclose the entire string using single quotes `'`:

```{r}
x <- 'I am trying to include a double quote " within my string'
writeLines(x)
```

**Solution**, using backslash (`\`) escape character

- To include a literal single quote `'` within our string we can use `\'` to "escape" a single quotation mark:

```{r}
my_string <- 'Escaping a single quote \' within single quotes'
writeLines(my_string)
```

```{r}
my_string <- "Escaping a double quote \" within double quotes"
writeLines(my_string)
```

<br>
Similarly, to include a literal backslash `\` in the string, we need to escape the backslash with another backslash:

```{r}
my_string <- "The executable is located in C:\\Program Files\\Git\\bin"
my_string
writeLines(my_string)
```

<br>
__Using backslash escape character (`\`) to include a special character in our string__

We create different versions of an object named `my_string` that contains special character `\t` for tab and special character `\n` for newline:

```{r}
my_string <- "A\tB" # contains \t tab
my_string
writeLines(my_string)

my_string <- "B\nC" # contains \n newline
my_string
writeLines(my_string)

my_string <- "A\tB\nC\tD" # contains \t tab and \n newline
writeLines(my_string)
```


<br>
**Summary**: We can use the backslash (`\`) escape character for:

- Referring to special characters, e.g.:
  - `\n`: newline
  - `\t`: tab
- Including a literal character in our string that would otherwise be interpreted as a special character:
  - `\'`: include literal single quote
  - `\"`: include literal double quote
  - `\\`: include literal backslash



## Functions for printing strings

Let's examine the object `my_string` (created below) which contains special characters `\t` for tab and `\n` for newline:

```{r}
my_string <- "A\tB\nC\tD" # contains \t tab and \n newline
writeLines(my_string)
```

<br>
When we print `my_string` using the `print()` function, the output looks different than printing it using `writeLines()`.

**Print using the `print()` function**

- This shows how the string text is stored by _R_ ("underlying string")
- We can see the enclosing double quotes (`"`) that _R_ uses to store the string
- Special characters like `\n` are printed literally (i.e., prints a literal backslash `\` followed by the letter `n`) rather than being interpreted as a newline character and displaying a line break

    ```{r}
    print(my_string) 
    my_string # same as printing my_string object using print()
    ```

**Print using the `writeLines()` function**

__The `writeLines()` function__:

```{r, eval = FALSE}
?writeLines

# SYNTAX AND DEFAULT VALUES
writeLines(text, con = stdout(), sep = "\n", useBytes = FALSE)
```

- Function: "`writeLines()` displays quotes and backslashes as they would be read, rather than as R stores them." (From [writeLines](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/writeLines) documentation)
- Arguments:
  - `text`: Character vector containing the text you want to display

    ```{r}
    writeLines(my_string)
    ```

Commentary on `writeLines()` function

- What it does: shows the string text as it is meant to be read by the end user
- Special characters like `\n` are interpreted so that the end user sees a new line inserted rather than seeing a literal `\n`
- Does not show the enclosing double (`"`) or single (`'`) quotes around the string, so we only see the content of the string
- Utility:
  - when we include **escape sequences** in the string, it is helpful to use `writeLines()` to see how the escaped string looks


<br>


## Backslashes and regular expressions

<!-- THIS QUOTE IS CONFUSING

> If `\` is used as an escape character in regular expressions, how do you match a literal `\`? Well you need to escape it, creating the regular expression `\\`. To create that regular expression, you need to use a string, which also needs to escape `\`. That means to match a literal `\` you need to write `\\\\` — you need four backslashes to match one!
your comment 

*Credit: [R for Data Science](https://r4ds.had.co.nz/strings.html#basic-matches) Strings Chapter*

-->


<br>

Regular expressions utilize special characters to match to text patterns. Many regular expression special characters start with a backslash `\`. For example, the regular expresion `\d` matches to any digit (e.g., `0`,`5`) in the text. 

Because `\` is an escape character in _R_, if we want to use the regular expression `\d` to match to any digit, we must write the regular expression out as `\\d`

<br>

For example, consider a string that is printed out like this by `writeLines()`:

- `The executable is located in C:\Program Files\Git\bin`
- This is like the text we would see on Twitter as an end user


But is stored internally in *R* like this, which is the way it is printed out by the `print()` function:

- `The executable is located in C:\\Program Files\\Git\\bin`
- This is how the Tweet is stored internally

Imagine our goal is to match the `\` (as it is seen on Twitter by the end user)

```{r}
my_string <- "The executable is located in C:\\Program Files\\Git\\bin"

my_string # printing an object shows how it is stored internally

writeLines(my_string) # Use writeLines() to see escaped string
```

The the pattern we need to match to in the (internally stored) text is `\\`. But this doesn't work:

```{r, eval=FALSE}
# This will give an error if we try to run it
str_view_all(string = my_string, pattern = "\\")
```

Why is that? Let's take a look at what is happening with the string `"\\"` we are providing as the `pattern` argument:

```{r}
# Use writeLines() to see the escaped string
writeLines("\\")
```

As seen, once escaped, the string `"\\"` becomes `\` - so we were providing `\` as the regular expression (i.e., `pattern` argument) instead of the `\\` that we wanted. In order to get `\\`, we need to use the string `"\\\\"`, where the 1st `\` escapes the 2nd and the 3rd `\` escapes the 4th:

```{r}
# Use writeLines() to see the escaped string
writeLines("\\\\")

# This properly matches the `\` in the string
str_view_all(string = my_string, pattern = "\\\\")
```

<br>
**Summary**: 

- Whenever we need to use backslash in our regular expression, we'll need to escape the backslash (by using another backslash) in the string that we provide as the regex `pattern`. 
- For example, to match a newline character `\n` we need to specify `"\\n"`, to match a tab character `\t` we need to specify `"\\t"`, etc.

<br>



# Regular expression basics {.tabset .tabset-fade .tabset-pills}

Example of using **regular expression** in action:

- How can we **match all occurrences of times** in the following string? (i.e., `10 AM` and `1 PM`)
  - `"Class starts at 10 AM and ends at 1 PM."`
- The **regular expression** `\d+ [AP]M` can!

```{r}
my_string = "Class starts at 10 AM and ends at 1 PM."
my_regex = "\\d+ [AP]M"

# The escaped string "\\d" results in the regex \d
writeLines(my_regex)

# View matches for our regular expression
str_view_all(string = my_string, pattern = my_regex)
```

- How the regular expression `\d+ [AP]M` works:
  - `\d+` matches 1 or more digits in a row
    - `\d` means match all numeric digits (i.e., `0`-`9`)
    - `+` means match 1 or more of
  - ` ` matches a literal space
  - `[AP]M` matches either `AM` or `PM`
    - `[AP]` means match either an `A` or `P` at that position
    - `M` means match a literal `M`

<br>
Some common **regular expression patterns** include (not inclusive):  

* Character classes
* Quantifiers 
* Anchors  
* Sets and ranges
* Groups and backreferences

*Credit: [DaveChild](https://cheatography.com/davechild/cheat-sheets/regular-expressions/) Regular Expression Cheat Sheet*


**Select each tab**


## Character classes

| STRING  <br>  *(type string that represents regex)* | REGEX <br> *(to have this appear in your regex)* | MATCHES <br> *(to match with this text)* |
|--------------|-----------------|---------|
| `"\\d"`  |    `\d`   |  any digit |
| `"\\D"`  |    `\D`   |  any non-digit|
| `"\\s"`  |    `\s`   |  any whitespace |
| `"\\S"`  |    `\S`   |  any non-whitespace |
| `"\\w"`  |    `\w`   |  any word character |
| `"\\W"`  |    `\W`   |  any non-word character|
| ***Other regex involving backslashes...*** |||
| `"\\n"`  |    `\n`   | newline  |
| `"\\t"`  |    `\t`   | tab |
| `"\\\\"` |    `\\`   | `\`  |
| `"\\."`  |    `\.`    | `.` |
| `"\\?"`  |    `\?`   | `?`  |
| `"\\("`  |    `\(`   | `(` |
| `"\\)"`  |    `\)`   | `)` |
| `"\\{"`  |    `\{`   | `{` |
| `"\\}"`  |    `\}`   | `}` |

*Credit: [Working with strings in stringr](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf) Cheat sheet*

<br>
There are certain **character classes** in regular expression that have special meaning. For example, `\d` is used to match any digit (i.e., _number_), `\s` is used to match any whitespace (i.e., _space, tab, or newline character_), and `\w` is used to match any word character (i.e., _alphanumeric character or underscore_). 

"But wait... there's more! Before a regex is interpreted as a regular expression, it is also interpreted by R as a string. And backslash is used to escape there as well. So, in the end, you need to preprend two backslashes..."  

*Credit: [Escaping sequences](https://stat545.com/character-vectors.html#escaping) from Stat 545*

This means in R, when we want to use regular expression patterns `"\d"`,`"\s"`, `"\w"`, etc. to match to strings, we must write out the regex patterns as `"\\d"`,`"\\s"`, `"\\w"`, etc.

<br>
**Example**: Using `\d` & `\D` to match digits & non-digits

Goal: write a regular expression pattern that matches to any digit in the string `p12_df$text[119]`
```{r}
# print string
p12_df$text[119]

# writeLines string
writeLines(p12_df$text[119])
```


We can use `\d` to match all instances of a digit (i.e., _number_):

```{r}
print("\\d")

# The escaped string "\\d" results in the regex \d
writeLines("\\d")

# Match any instances of a digit
str_view_all(string = p12_df$text[119], pattern = "\\d")
```

What if we defined our our regex pattern as `"\d"` instead of `"\\d"`?
```{r, eval = FALSE}
# Error: '\d' is an unrecognized escape in character string starting ""\d"
print("\d")

writeLines("\d") # Error: '\d' is an unrecognized escape in character string starting ""\d"

# Error: '\d' is an unrecognized escape in character string starting ""\d"
str_view_all(string = p12_df$text[119], pattern = "\d")
```
The correct regular expression pattern to match any digits
```{r}
str_view_all(string = p12_df$text[119], pattern = "\\d")
```

__KEY POINT__

- Our regular expression is the value we specify for the `pattern` argument above; this is our "regex object"
- We want our regex object to include the regular expression `\d`, which matches to any digit
- We specify our regex object as `"\\d"` rather than `"\d"`


__EXPLAINING WHY THIS KEY POINT IS TRUE__

- our regex object is first interpreted by _R_ as a string before it is interpreted as a regular expression
- In *R*, a backslash `\` is an escape character
- we want our regex object to include a singled backslash `\` after it is interpreted by _R_, 
- So the specification of our regex object must include two backslashes in a row `\\` 
  - the purpose of the first backslash is to escape the second backslash, because a backslash is a special character in _R_

__TAKEAWAY__

- write your regex object the way it be printed by the `print()` function
- because before the regex object is interpreted as a regular expression, it is interpreted by *R* the way it would be printed by the `writeLines()` function

```{r}
# so, write your regex object like this
print("\\d")

#so it will be interpreted like this
writeLines("\\d")
```



<br>
__Example__: use regular expression `\D` to match all instances of a non-digit character:

```{r}
# The escaped string "\\D" results in the regex \D
writeLines("\\D")

# Match any instances of a non-digit
str_view_all(string = p12_df$text[119], pattern = "\\D")
```

<br>
__Example__: match to all instances of a digit followed by a non-digit character:

```{r}
str_view_all(string = p12_df$text[119], pattern = "\\d\\D")
```

</details>

<br>
<details><summary>**Example**: Using `\s` & `\S` to match whitespace & non-whitespace</summary>

We can use `\s` to match all instances of a whitespace (i.e., _space, tab, or newline character_):

```{r}
# The escaped string "\\s" results in the regex \s
writeLines("\\s")

# Match any instances of a whitespace
str_view_all(string = p12_df$text[119], pattern = "\\s")
```

<br>
We can use `\S` to match all instances of a non-whitespace character:

```{r}
# The escaped string "\\S" results in the regex \S
writeLines("\\S")

# Match any instances of a non-whitespace
str_view_all(string = p12_df$text[119], pattern = "\\S")
```

<br>
This matches all instances of the letter `e` followed by a whitespace character:

```{r}
str_view_all(string = p12_df$text[39], pattern = "e\\s")
```

</details>

<br>
<details><summary>**Example**: Using `\w` & `\W` to match words & non-words</summary>

We can use `\w` to match all instances of a word character (i.e., _alphanumeric character or underscore_):

```{r}
# The escaped string "\\w" results in the regex \w
writeLines("\\w")

# Match any instances of a word character
str_view_all(string = p12_df$text[119], pattern = "\\w")
```

<br>
We can use `\W` to match all instances of a non-word character:

```{r}
# The escaped string "\\W" results in the regex \W
writeLines("\\W")

# Match any instances of a non-word character
str_view_all(string = p12_df$text[119], pattern = "\\W")
```

<br>
This matches all instances of 3-letter words:

```{r}
str_view_all(string = p12_df$text[119], pattern = "\\W\\w\\w\\w\\W")
```

</details>

<br>
The second half of the table above shows other regular expressions involving backslashes. This includes special characters like `\n` and `\t`, as well as using backslash to escape characters that have special meanings in regex, like `.` or `?` (as we will soon see). So to match a literal period or question mark, we need to use the regex `\.` and `\?`, or strings `"\\."` and `"\\?"` in R.
<br>

***

## Quantifiers


Character  Description   
---------- ------------  
`*`        0 or more       
`?`        0 or 1          
`+`        1 or more       
`{3}`      Exactly 3
`{3,}`     3 or more
`{3,5}`    3, 4, or 5

<br>
We can use **quantifiers** to specify the amount of a certain character or expression to match. The quantifier should directly follow the pattern you want to quantify. For example, `s?` matches 0 or 1 `s` and `\d{4}` matches exactly 4 digits.                   

<br>
<details><summary>**Example**: Using the `*`, `?`, and `+` quantifiers</summary>

We can use `*` to match 0 or more of a pattern:

```{r}
# Matches all instances of `s` followed by 0 or more non-word character
str_view_all(string = p12_df$text[119], pattern = "s\\W*")
```

<br>
We can use `?` to match 0 or 1 of a pattern:

```{r}
# Matches all instances of `s` followed by 0 or 1 non-word character
str_view_all(string = p12_df$text[119], pattern = "s\\W?")
```

<br>
We can use `+` to match 1 or more of a pattern:

```{r}
# Matches all instances of `s` followed by 1 or more non-word character
str_view_all(string = p12_df$text[119], pattern = "s\\W+")

# Matche all twitter hashtags
  # hashtag defined as hashtag character # followed by 1 or more word characters
str_view_all(string = p12_df$text[119], pattern = "#\\w+")
```

</details>


<br>
<details><summary>**Example**: Using `{...}` to specify how many occurrences to match</summary> 

We can use `{n}` to specify the exact number of characters or expressions to match: 

```{r}
# Matches words with exactly 3 letters
str_view_all(string = p12_df$text[119], pattern = "\\s\\w{3}\\s")
```


<br>
We can use `{n,}` to specify `n` as the minimum amount to match: 

```{r}
# Matches words with 3 or more letters
str_view_all(string = p12_df$text[119], pattern = "\\s\\w{3,}\\s")
```

<br>
We can use `{n,m}` to specify we want to match between `n` and `m` amount (inclusive): 

```{r}
# Matches words with between 3 to 5 letters (inclusive)
str_view_all(string = p12_df$text[119], pattern = "\\s\\w{3,5}\\s")
```

</details>
<br>

***  

## Anchors

String     Character  Description     
---------- ---------- ----------------------------------------------------------  
 `"^"`      `^`       Start of string, or start of line in multi-line pattern         
 `"$"`      `$`           End of string, or end of line in multi-line pattern    
 `"\\b"`    `\b`                                                Word boundary
 `"\\B"`    `\B`                                            Non-word boundary

 
<br>
We can use **anchors** to indicate which part of the string to match. For example, `^` matches the start of the string, `$` matches the end of the string (*Notice how we do not need to escape these characters*). `\b` can be used to help detect word boundaries, and `\B` can be used to help match characters within a word.

<br>
<details><summary>**Example**: Using `^` & `$` to match start & end of string</summary> 

We can use `^` to match the start of a string: 

```{r}
# Matches only the quotation mark at the start of the text and not the end quote
str_view_all(string = p12_df$text[119], pattern = '^"')
```


<br>
We can use `$` to match the end of a string: 

```{r}
# Matches only the number at the end of the text and not any other numbers
str_view_all(string = p12_df$text[119], pattern = "\\d$")
```

</details>


<br>
<details><summary>**Example**: Using `\b` & `\B` to match word boundary & non-word boundary</summary> 

We can use `\b` to help detect word boundary: 
```{r}
# Match to all word bounraries
str_view_all(string = p12_df$text[119], pattern = "\\b")
```


```{r}
# Matches words with 3 or more letters using \b
str_view_all(string = p12_df$text[119], pattern = "\\b\\w{3,}\\b")
```

Notice how this is much flexible than trying to use whitespace (`\s`) to determine word boundary:

```{r}
# Matches words with 3 or more letters using \s
str_view_all(string = p12_df$text[119], pattern = "\\s\\w{3,}\\s")
```

Regular expression `\B` matches to "non-word boundary"; what does that mean?
```{r}
str_view_all(string = p12_df$text[119], pattern = "\\B")
```


<br>
We can use `\B` to help match characters within a word: 

```{r}
# Matches only the letter `s` within a word and not at the start or end
str_view_all(string = p12_df$text[119], pattern = "\\Bs\\B")
```

</details>
<br>

***

## Sets and ranges

Character  Description     
---------- ----------------------------------------------------------
`.`        Match any character except newline (`\n`)
`a|b`      Match `a` or `b`
`[abc]`    Match either `a`, `b`, or `c`
`[^abc]`   Match anything except `a`, `b`, or `c`
`[a-z]`    Match range of lowercase letters from `a` to `z`
`[A-Z]`    Match range of uppercase letters from `A` to `Z`
`[0-9]`    Match range of numbers from `0` to `9`


<br>
The table above lists some more ways regular expression offers us flexibility and option in what we want to match. The period `.` acts as a **wildcard** to match any character except newline. The vertical bar `|` is similar to an **OR** operator. Square brackets `[...]` can be used to specify a set or range of characters to match (or not to match).

<br>
<details><summary>**Example**: Using `.` as a wildcard</summary> 

We can use `.` to match any character except newline (`\n`): 

```{r}
# Matches any character except newline
str_view_all(string = p12_df$text[119], pattern = ".")
```

<br>
We can confirm there is a newline in the tweet above by using `writeLines()` or `print()`:

```{r}
writeLines(p12_df$text[119])

print(p12_df$text[119])
```

</details>

<br>
<details><summary>**Example**: Using `|` as an OR operator</summary> 

We can use `|` to match either one of multiple patterns: 

```{r}
# Matches `research`, `fight`, or `labs`
str_view_all(string = p12_df$text[119], pattern = "research|fight|labs")

# Matches hashtags or handles
str_view_all(string = p12_df$text[119], pattern = "@\\w+|#\\w+")
```

</details>


<br>
<details><summary>**Example**: Using `[...]` to match (or not match) a set or range of characters</summary> 

We can use `[...]` to match any set of characters: 

```{r}
# Matches hashtags or handles
str_view_all(string = p12_df$text[119], pattern = "[@#]\\w+")

# Matches any 2 consecutive vowels
str_view_all(string = p12_df$text[119], pattern = "[aeiouAEIOU]{2}")
```

<br>
We can also use `[...]` to match any range of alpha or numeric characters: 

```{r}
# Matches only lowercase x through z or uppercase A through C
str_view_all(string = p12_df$text[119], pattern = "[x-zA-C]")

# Matches only numbers 1 through 4 or the pound sign
str_view_all(string = p12_df$text[119], pattern = "[1-4#]")
```

<br>
We can use `[^...]` to indicate we do not want to match the provided set or range of characters:

```{r}
# Matches any vowels
str_view_all(string = p12_df$text[119], pattern = "[aeiouAEIOU]")

# Matches anything except vowels
str_view_all(string = p12_df$text[119], pattern = "[^aeiouAEIOU]")

# Matches anything that's not uppercase letters
str_view_all(string = p12_df$text[119], pattern = "[^A-Z]+")
```

Notice that `[...]` only matches a single character (see second to last example above). We need to use quantifiers if we want to match a stretch of characters (see last example above).

</details>
<br>

***

## Groups and backreferences

String      Character  Description     
-------     ---------- ----------------------------------------------------------
`"(...)"`   `(...)`      Capturing group
`"(?:...)"` `(?:...)`    Non-capturing group
`"\\1"`     `\1`         Part of the string matched by capturing group 1
`"\\2"`     `\2`         Part of the string matched by capturing group 2
...         ...          ...

<br>
Parentheses can be used to group parts of our regular expression together. Normal parentheses `(...)` creates what is called a numbered **capturing group**. "A capturing group stores the part of the string matched by the part of the regular expression inside the parentheses". For example, if we have `(\d)`, we can refer back to the digit matched by this capturing group using backreferences, like `\1`.

*Credit: Hadley Wickham ([R for Data Science](https://r4ds.had.co.nz/strings.html#grouping-and-backreferences)) Grouping and backreferences*

If we only want to use parentheses for grouping purposes and do not need to reference the matched values, we can use a **non-capturing group** `(?:...)`.

<br>
<details><summary>**Example**: Using capturing groups `(...)` and backreferences</summary> 

We can use capturing groups `(...)` to match certain patterns, then reference what was matched: 

```{r}
# Matches any letter that is repeated 2 times in a row
str_view_all(string = p12_df$text[119], pattern = "([A-Za-z])\\1")

# Matches any string of characters where the first and last letters are the same,
# and the second and least letters are the same
str_view_all(string = p12_df$text[119], pattern = "([a-z])([a-z]).*\\2\\1")
```

</details>

<br>
<details><summary>**Example**: Using non-capturing groups `(?:...)` for grouping purposes</summary> 

We can use non-capturing groups `(?:...)` if we just want to group certain parts of the regex but don't need to reference the matched value: 

```{r}
# Matches one or more of a digit followed by 3 letters
str_view_all(string = p12_df$text[119], pattern = "(?:\\d[A-Za-z]{3})+")
```

<br>
Normal parentheses (capturing groups) can still work for general grouping purposes too. But if you want to group things together without capturing them, you can just use non-capturing groups:

```{r}
# Here, we have 2 capturing groups but only need to reference the 2nd
str_view_all(string = "A1A1A1eeee", pattern = "([A-Z]\\d)+([a-z])\\2{2}")

# So we can just turn the first group into a non-capturing group
str_view_all(string = "A1A1A1eeee", pattern = "(?:[A-Z]\\d)+([a-z])\\1{2}")
```

</details>
<br>

***

# Regex with `stringr` functions

This section is about how to solve problems by using regular expressions in combination with functions from the `stringr` package. This section closely follows section [14.4 Tools](https://r4ds.had.co.nz/strings.html#tools) from __R for Data Science__ by Wickham and Grolemund.

<br>

From __R for Data Science__ [14.4 Tools](https://r4ds.had.co.nz/strings.html#tools):

> A word of caution before we continue: because regular expressions are so powerful, it’s easy to try and solve every problem with a single regular expression. In the words of Jamie Zawinski:

>> Some people, when confronted with a problem, think “I know, I’ll use regular expressions.” Now they have two problems.

> Don’t forget that you’re in a programming language and you have other tools at your disposal. Instead of creating one complex regular expression, it’s often easier to write a series of simpler regexps. If you get stuck trying to create a single regexp that solves your problem, take a step back and think if you could break the problem down into smaller pieces, solving each challenge before moving onto the next one.

## `stringr` package overview

The `stringr` package is part of the `tidyverse` suite of packages.

The `stringr` package is built on top of the `stringi` package. 

- The `stringi` package is designed to handle every possible challenge one might encounter in working with strings and contains around 250 functions. 
- By contrast, the `stringr` package contains around 50 functions -- a subset of `stringi` functions -- "which have been carefully picked to handle the most common string manipulation functions" [@wickham_rds, section 14.7]


You can perform most/all regular expression tasks using either `Base R` or `stringi`, so why use the `stringr` package? 

Functions from the `stringr` package are nice to work with for a few reasons, most of which relate to consistency (as described in the [stringr.tidyverse.org](https://stringr.tidyverse.org/) page):

- All `stringr` functions in start with `str_` (e.g., `str_view()`, `str_subset()`, `str_replace`)
- All `stringr` functions take a vector of strings as the first argument
- Most `stringr` are designed to utilize regular expressions

This section will introduce the most commonly used `stringr` functions -- Wickham refers to these functions as "verbs" -- for working with string patterns. 

In each of the following functions, argument `x` is a vector of strings; and argument `pattern` is the pattern to look for within string `x`, which often utilizes regular expressions:

- `str_detect(x, pattern)`: `TRUE/FALSE` if there is a match to the pattern
- `str_subset(x, pattern)`: extracts the matching components
- `str_extract(x, pattern)`: extracts the text of the match
- `str_match(x, pattern)`: extracts parts of the match defined by parentheses
- `str_replace(x, pattern, replacement)`: replaces the matches with new text
- `str_split(x, pattern)`: splits a string into multiple pieces
- `str_count(x, pattern)`: counts the number of matches to the pattern
- `str_locate(x, pattern)`: gives the position of the match

### `regex()` function

(From [R for Data Science, section 14.5](https://r4ds.had.co.nz/strings.html#other-types-of-pattern))

When we specify a value for the `pattern` argument of a `stringr` function -- such as `str_view()` -- it is automatically wrapped in a call to the `regex()` function (i.e., _it is treated as a regular expression_)

  ```{r}
  # This function call:
  str_view(string = "Turn to page 394...", pattern = "\\d+")
  
  # Is shorthand for:
  str_view(string = "Turn to page 394...", pattern = regex(pattern = "\\d+"))
  ```
  
- For simplicity, we can omit the call to to the `regex()` function
- But, there are additional arguments we can supply to `regex()` if we wanted  

`regex(pattern, ignore_case = FALSE, multiline = FALSE, comments = FALSE, ...)`  

- `ignore_case`: If `TRUE`, allows characters to match either their uppercase or lowercase forms  
- `multiline`: If `TRUE`, allows `^` and `$` to match the start and end of each line within an element rather than the start and end of the complete string  
- `comments`: If `TRUE`, allows you to use comments and whitespace to make complex regular expressions more understandable  
  - Spaces are ignored, as is everything after `#`  
  - To match a literal space, you’ll need to escape it: `"\\ "`

<br>
<details><summary>**Example**: Specifying `ignore_case = TRUE` in `regex()`</summary>

Let's say we have the following string:

```{r}
s <- "Yay, yay.... YAY!"
s
```

<br>
We can match all the yay's using the following regex:

```{r}
str_view_all(string = s, pattern = "[Yy][Aa][Yy]")
```

<br>
Equivalently, we can specify `ignore_case = TRUE` to avoid dealing with casing variations:

```{r}
str_view_all(string = s, pattern = regex("yay", ignore_case = TRUE))
```

</details>




## `str_detect()`

<br>
__The `str_detect()` function__:

```{r, eval = FALSE}
?str_detect

# SYNTAX AND DEFAULT VALUES
str_detect(string, pattern, negate = FALSE)
```

- Function: Detects the presence or absence of a pattern in a string, separately for each element of the string
  - Returns logical vector (`TRUE` if there is a match, `FALSE` if there is not)
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for
  - `negate`: If set to `TRUE`, the returned logical vector will contain `TRUE` if there is not a match and `FALSE` if there is one

<br>
<details><summary>**Example**: Using `str_detect()` on string</summary>

```{r}
# Detects if there is a digit in the string
str_detect(string = "P. Sherman 42 Wallaby Way", pattern = "\\d")
```

</details>

<br>
<details><summary>**Example**: Using `str_detect()` on character vector</summary>

```{r}
# Detects if there is a digit in each string in the vector
str_detect(string = c("One", "25th", "3000"), pattern = "\\d")
```

</details>

<br>
<details><summary>**Example**: Using `str_detect()` on dataframe column</summary>

Consider the variable `created_at` from data frame `p12_df`
```{r}
# print a few obs
p12_df %>% select(user_id,screen_name,created_at) %>% head(n=5)

# examine variable type
p12_df$created_at %>% str()
```

Let's create new columns in `p12_df` called `is_am` and `is_pm` that indicates whether or not each tweet's `created_at` time is in the AM or PM, respectively:

```{r}
p12_df %>%
  mutate(
    # Returns `TRUE` if the hour is 0#, 10, or 11, `FALSE` otherwise
    is_am = str_detect(string = created_at, pattern = " 0\\d| 1[01]"),
    # Recall we can set the `negate` argument to switch the returned `TRUE`/`FALSE`
    is_pm = str_detect(string = created_at, pattern = " 0\\d| 1[01]", negate = TRUE)
  ) %>% select(created_at, is_am, is_pm)
```

<br>
Because `TRUE` evaluates to 1 and `FALSE` evaluates to 0 in a numerical context, we could also sum the returned logical vector to see how many of the elements in the vector had a match:

```{r}
# Number of tweets that were created in the AM
num_am_tweets <- sum(str_detect(string = p12_df$created_at, pattern = " 0\\d| 1[01]"))
num_am_tweets
```

<br>
Additionally, we can take the average of the logical vector to get the proportion of elements in the input vector that had a match:

```{r}
# Proportion of tweets that were created in the AM
pct_am_tweets <- mean(str_detect(string = p12_df$created_at, pattern = " 0\\d| 1[01]"))
pct_am_tweets
```

<br>
We can also use the logical vector returned from `str_detect()` to filter `p12_df` to only include rows that had a match:

```{r}
# Keep only rows whose tweet was created in the AM
p12_df %>%
  filter(str_detect(string = created_at, pattern = " 0\\d| 1[01]") == TRUE)
```

</details>

## `str_subset()`

<br>
__The `str_subset()` function__:

```{r, eval = FALSE}
?str_subset

# SYNTAX AND DEFAULT VALUES
str_subset(string, pattern, negate = FALSE)
```

- Function: Keeps strings that match a pattern
  - Returns input vector filtered to only keep elements that match the specified pattern
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for
  - `negate`: If set to `TRUE`, the returned vector will contain only elements that did not match the specified pattern

<br>
<details><summary>**Example**: Using `str_subset()` on character vector</summary>

```{r}
# Subsets the input vector to only keep elements that contain a digit
str_subset(string = c("One", "25th", "3000"), pattern = "\\d")

# thus, the vector returned by str_subset() usually contains fewer elements than input string
c("One", "25th", "3000") %>% length()
str_subset(string = c("One", "25th", "3000"), pattern = "\\d") %>% length()
```

</details>

<br>
<details><summary>**Example**: Using `str_subset()` on dataframe column</summary>

```{r}
# Subsets the `created_at` vector of `p12_df` to only keep elements that occured in the AM
str_subset(string = p12_df$created_at, pattern = " 0\\d| 1[01]")

p12_df$created_at %>% length()
str_subset(string = p12_df$created_at, pattern = " 0\\d| 1[01]") %>% length()
```

</details>

## `str_extract()` & `str_extract_all()`

<br>
__The `str_extract()` & `str_extract_all()` functions__:

```{r, eval = FALSE}
?str_extract
?str_extract_all

# SYNTAX AND DEFAULT VALUES
str_extract(string, pattern)
str_extract_all(string, pattern, simplify = FALSE)
```

- Function: Extracts matching patterns from a string
  - Returns first match (`str_extract()`) or all matches (`str_extract_all()`) for input vector
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for
  - `simplify`: If set to `TRUE`, the returned matches will be in a character matrix rather than the default list of character vectors

How `str_extract()` differs from `str_subset()`

- `str_subset()` returns the entire element of the elements that match the pattern
- `str_extract()` returns character vector that contains the part of the element that matches; and returns NA for elements w/ no match
```{r}
# str_subset() returns the entire element of the elements that match the pattern
str_subset(string = c("One", "25th", "3000"), pattern = "\\d+")
str_subset(string = c("One", "25th", "3000"), pattern = "\\d+") %>% length()

# str_extract() returns just the part of the element that matches; and returns NA for elements w/ no match
str_extract(string = c("One", "25th", "3000"), pattern = "\\d+")
str_extract(string = c("One", "25th", "3000"), pattern = "\\d+") %>% length()
```


<br>
<details><summary>**Example**: Using `str_extract()` & `str_extract_all()` on character vector</summary>

**[`str_extract()`]** Extract the first occurrence of a word for each string:

```{r}
# Extracts first match of a word
str_extract(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"),
            pattern = "\\w+")
```
```{r}
# Extracts first match to element that begins with "A"
str_extract(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"),
            pattern = "^A")

# note that length of vector returned by str_extract() is same as length of input string
c("Three French hens", "Two turtle doves", "A partridge in a pear tree") %>% length()

str_extract(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"),
            pattern = "^A") %>% length()
```

**[`str_extract_all()`]** Extract all occurrences of a word for each string:


```{r}
# Extracts all matches of a word, returning a list of character vectors
str_extract_all(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"), 
                pattern = "\\w+")

# Extracts all matches of a word, setting simplify = TRUE returns a character matrix
str_extract_all(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"), 
                pattern = "\\w+", simplify = TRUE)
```
By default, whereas `str_extract()` returns a character vector `str_extract_all()` returns a list
Types of objects returned by `str_extract()` and `str_extract_all()`
```{r}
# str_extract returns a character vector
str_extract(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"), 
                pattern = "\\w+") %>% str()

# by default, str_extract_all returns a list
str_extract_all(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"), 
                pattern = "\\w+") %>% str()

# str_extract_all with simplify = TRUE returns a character matrix
str_extract_all(string = c("Three French hens", "Two turtle doves", "A partridge in a pear tree"), 
                pattern = "\\w+", simplify = TRUE) %>% str()
```

</details>

<br>
<details><summary>**Example**: Using `str_extract()` & `str_extract_all()` on dataframe column</summary>

**[`str_extract()`]** Extract first hashtag:

```{r}
# Extracts first match of a hashtag (if there is one)
p12_df %>% 
  mutate(
    hashtag = str_extract(string = text, pattern = "#\\S+") # pattern is a hashtag followed by one or more non-white-space characters
  ) %>% select(text, hashtag)
```

**[`str_extract_all()`]** Extract all hashtags:

```{r}
# Extracts all matches of hashtags (if there are any)
p12_df %>% 
  mutate(
    hashtag_vector = str_extract_all(string = text, pattern = "#\\S+"),
    # Use `as.character()` so we can see the content of the character vector of matches
    hashtags = as.character(hashtag_vector)
  ) %>% select(text, hashtag_vector, hashtags)
```

</details>

## `str_match()` & `str_match_all()`

<br>
__The `str_match()` & `str_match_all()` functions__:

```{r, eval = FALSE}
?str_match
?str_match_all

# SYNTAX
str_match(string, pattern)
str_match_all(string, pattern)
```

- Function: Extracts matched capturing groups from a string
  - Returns a character matrix containing the full match in the first column, then additional columns for matches from each capturing group
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for




<br>
<details><summary>**Example**: Using `str_match()` & `str_match_all()` on character vector</summary>

**[`str_match()`]** Extract the first month, day, year for each string:

```{r}
# we a string of 3-elements with dates stored in MDY format, but each stored slighlty different 
c("5-1-2020", "12/25/17", "01.01.13 to 01.01.14")

# Use str_match to extracts first match of month, day, year, separating month day and year using capturing groups
str_match(string = c("5-1-2020", "12/25/17", "01.01.13 to 01.01.14"),
          pattern = "(\\d+)[-/\\.](\\d+)[-/\\.](\\d+)")
  # note: pattern is digit one or more times followed by "-" or "."; then digit one ore more times ....
```

`str_match()` returns a character matrix
```{r}
m <- str_match(string = c("5-1-2020", "12/25/17", "01.01.13 to 01.01.14"),
          pattern = "(\\d+)[-/\\.](\\d+)[-/\\.](\\d+)")

m %>% str() # character matrix of threw rows and four columns

m # print entire character matrix

m[1,] # isolate first row

m[,1] # isolate first column

m[,4] # isolate fourth column

m[3,4] # isolate cell defined by row 3 and column 4
```

How `str_match()` differs from `str_extract()`


```{r}
# str_match(): first column contains full match; then separate columns for matches from each capturing group
str_match(string = c("5-1-2020", "12/25/17", "01.01.13 to 01.01.14"),
          pattern = "(\\d+)[-/\\.](\\d+)[-/\\.](\\d+)")


#`str_extract()` returns character vector with each element containing full match; doesn't return separate elements for each matching group
str_extract(string = c("5-1-2020", "12/25/17", "01.01.13 to 01.01.14"),
          pattern = "(\\d+)[-/\\.](\\d+)[-/\\.](\\d+)")
```


**[`str_match_all()`]** Extract all month, day, year for each string:

Whereas `str_match()` returns a character matrix containing text from the first match, `str_match_all()` returns a list containing text from all matches; and each element in the list is a character matrix

```{r}
# Extracts all matches of month, day, year
str_match_all(string = c("5-1-2020", "12/25/17", "01.01.13 to 01.01.14"),
              pattern = "(\\d+)[-/\\.](\\d+)[-/\\.](\\d+)")

# examine structure created by str_match_all
str_match_all(string = c("5-1-2020", "12/25/17", "01.01.13 to 01.01.14"),
              pattern = "(\\d+)[-/\\.](\\d+)[-/\\.](\\d+)") %>% str()
```

</details>

<br>
<details><summary>**Example**: Using `str_match()` on dataframe column</summary>

Below, we extract datetime from the `created_at` column. The first capturing group matches the date part and the second capturing group matches the time part:

```{r}
datetime_regex <- "([\\d-]+) ([\\d:]+)"
p12_df %>%
  mutate(
    # The 1st capturing group will be in the 2nd column of the matrix returned from `str_match()`
    # So we use [, 2] below and save the result to the `date` column of the dataframe
    date = str_match(string = created_at, pattern = datetime_regex)[, 2],
    # The 2nd capturing group will be in the 3rd column of the matrix returned from `str_match()`
    # So we use [, 3] below and save the result to the `time` column of the dataframe
    time = str_match(string = created_at, pattern = datetime_regex)[, 3]
  ) %>% select(created_at, date, time)
```

</details>


## `str_replace()` & `str_replace_all()`

<br>
__The `str_replace()` & `str_replace_all()` functions__:

```{r, eval = FALSE}
?str_replace
?str_replace_all

# SYNTAX
str_replace(string, pattern, replacement)
str_replace_all(string, pattern, replacement)
```

- Function: Replaces matched patterns in a string
  - Returns input vector with first match (`str_replace()`) or all matches (`str_replace_all()`) for each string replaced with specified replacement
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for
  - `replacement`: What the matched pattern should be replaced with
- `str_replace_all()` also supports multiple replacements, where you can omit the `replacement` argument and just provide a named vector of replacements as the `pattern`

<br>
<details><summary>**Example**: Using `str_replace()` & `str_replace_all()`</summary>

**[`str_replace()`]** Replace the first occurrence of a vowel:

```{r}
# Replace first vowel with empty string
str_replace(string = "Thanks for the Memories", pattern = "[aeiou]", replacement = "")
```

**[`str_replace_all()`]** Replace all occurrences of a vowel:

```{r}
# Replace all vowels with empty strings
str_replace_all(string = "Thanks for the Memories", pattern = "[aeiou]", replacement = "")
```

</details>

<br>
<details><summary>**Example**: Using backreferences with `str_replace()` & `str_replace_all()`</summary>

**[`str_replace()`]** Change first word that is matched to pig latin:

```{r}
# Use \\1 and \\2 to refer to the capturing groups
str_replace(string = "pig latin", pattern = "(\\w{1})(\\w+)",
            replacement = "\\2\\1ay")

# this works too
str_replace(string = "pig latin", pattern = "(\\w)(\\w+)",
            replacement = "\\2\\1ay")
```

**[`str_replace_all()`]** Change all words to pig latin:

```{r}
# Use \\1 and \\2 to refer to the capturing groups
str_replace_all(string = "pig latin", pattern = "(\\w{1})(\\w+)",
                replacement = "\\2\\1ay")
```

</details>

<br>
<details><summary>**Example**: Using `str_replace_all()` for multiple replacements</summary>

```{r}
# Replace all occurrences of "at" with "@", and all digits with "#"
str_replace_all(string = "Tomorrow at 10:30AM", pattern = c("at" = "@", "\\d" = "#"))
```

</details>

<br>
<details><summary>**Example**: Using `str_replace_all()` on dataframe column</summary>

```{r}
p12_df %>%
  mutate(
    # Replace all hashtags and handles from tweet with an empty string
    removed_hashtags_handles = str_replace_all(string = text, pattern = "[@#]\\S+", replacement = "")
  ) %>% select(text, removed_hashtags_handles)
```

</details>


## `str_split()`

<br>
__The `str_split()` function__:

```{r, eval = FALSE}
?str_split

# SYNTAX AND DEFAULT VALUES
str_split(string, pattern, n = Inf, simplify = FALSE)
```

- Function: Splits a string by specified pattern
  - [by default] returns a list that contains character vectors containing the split substrings
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for and split by
  - `n`: Maximum number of substrings to return
  - `simplify`: If set to `TRUE`, the returned matches will be in a character matrix rather than the default list of character vectors

<br>
<details><summary>**Example**: Using `str_split()` on character vector</summary>

```{r}
# Split by comma or the word "and"
str_split(string = c("The Lion, the Witch, and the Wardrobe", "Peanut butter and jelly"),
          pattern = ",? and |, ")
```

<br>
We can specify `n` to control the maximum number of substrings we want to return:

```{r}
# Limit split to only return 2 substrings
str_split(string = c("The Lion, the Witch, and the Wardrobe", "Peanut butter and jelly"),
          pattern = ",? and |, ", n = 2)
```

<br>
We can specify `simplify = TRUE` to return a character matrix instead of a list:

```{r}
# Return split substrings in a character matrix
str_split(string = c("The Lion, the Witch, and the Wardrobe", "Peanut butter and jelly"),
          pattern = ",? and |, ", simplify = TRUE)
```

</details>

<br>
<details><summary>**Example**: Using `str_split()` on dataframe column</summary>

When we split the `created_at` field at either a hyphen or space, we can separated out the year, month, day, and time components of the string:

```{r}
p12_df %>%
  mutate(
    # Use `as.character()` so we can see the content of the character vector of splitted strings
    year_month_day_time = as.character(str_split(string = created_at, pattern = "[- ]"))
  ) %>% select(created_at, year_month_day_time)
```

</details>

## `str_count()`

<br>
__The `str_count()` function__:

```{r, eval = FALSE}
?str_count

# SYNTAX AND DEFAULT VALUES
str_count(string, pattern = "")
```

- Function: Counts the number of matches in a string
  - Returns the number of matches
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for

<br>
<details><summary>**Example**: Using `str_count()` on character vector</summary>

```{r}
# Counts the number of digits
str_count(string = c("H2O2", "Year 3000", "4th of July"), pattern = "\\d")
```

</details>

<br>
<details><summary>**Example**: Using `str_count()` on dataframe column</summary>

```{r}
p12_df %>%
  mutate(
    # Counts the total number of hashtags and mentions
    num_hashtags_and_mentions = str_count(string = text, pattern = "[@#]\\S+")
  ) %>% select(text, num_hashtags_and_mentions)
```

</details>


## `str_locate()` & `str_locate_all()`

<br>
__The `str_locate()` & `str_locate_all()` functions__:

```{r, eval = FALSE}
?str_locate
?str_locate_all

# SYNTAX
str_locate(string, pattern)
str_locate_all(string, pattern)
```

- Function: Locates the position of patterns in a string
  - Returns an integer matrix containing the start position of match in the first column and end position of match in second column
- Arguments:
  - `string`: Character vector (or vector coercible to character) to search
  - `pattern`: Pattern to look for

<br>
<details><summary>**Example**: Using `str_locate()` & `str_locate_all()` on character vector</summary>

**[`str_locate()`]** Locate the start and end positions for first stretch of numbers:

```{r}
# Locate positions for first stretch of numbers
str_locate(string = c("555.123.4567", "(555) 135-7900 and (555) 246-8000"),
           pattern = "\\d+")
```

**[`str_locate_all()`]** Locate the start and end positions for all stretches of numbers:

```{r}
# Locate positions for all stretches of numbers
str_locate_all(string = c("555.123.4567", "(555) 135-7900 and (555) 246-8000"),
               pattern = "\\d+")

# basically, str_locate_all gives the positions associated wtih elements 
str_extract_all(string = c("555.123.4567", "(555) 135-7900 and (555) 246-8000"),
               pattern = "\\d+")
```

</details>

<br>
<details><summary>**Example**: Using `str_locate()` on dataframe column</summary>

```{r}
p12_df %>%
  mutate(
    # Start position of first hashtag in tweet (ie. 1st column of matrix returned from `str_locate()`)
    start_of_first_hashtag = str_locate(string = text, pattern = "#\\S+")[, 1],
    # End position of first hashtag in tweet (ie. 2nd column of matrix returned from `str_locate()`)
    end_of_first_hashtag = str_locate(string = text, pattern = "#\\S+")[, 2],
    # Length of first hashtag in tweet (ie. difference between start and end positions)
    length_of_first_hashtag = end_of_first_hashtag - start_of_first_hashtag
  ) %>% select(text, start_of_first_hashtag, end_of_first_hashtag, length_of_first_hashtag)
```

</details>


# Appendix

## RegExplain Addin  

> Regular expressions are tricky. RegExplain makes it easier to see what you’re doing.

![](https://raw.githubusercontent.com/anyone-can-cook/rclass2/main/assets/images/regexplain.png)

*Credit: Garrick Aden-Buie ([RegExplain](https://www.garrickadenbuie.com/project/regexplain/))*

<br>
**RegExplain** is an RStudio addin that allows the user to check their regex matching functions interactively.

```{r eval=FALSE}
# Installation
devtools::install_github("gadenbuie/regexplain")
library(regexplain)
```

## References

