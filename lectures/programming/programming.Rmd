---
title: "Programming in R"
author: 
date: 
urlcolor: blue
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true # toc_float option to float the table of contents to the left of the main document content. floating table of contents will always be visible even when the document is scrolled
      #collapsed: false # collapsed (defaults to TRUE) controls whether the TOC appears with only the top-level (e.g., H2) headers. If collapsed initially, the TOC is automatically expanded inline when necessary
      #smooth_scroll: true # smooth_scroll (defaults to TRUE) controls whether page scrolls are animated when TOC items are navigated to via mouse clicks
    number_sections: true
    fig_caption: true # ? this option doesn't seem to be working for figure inserted below outside of r code chunk    
    highlight: tango # Supported styles include "default", "tango", "pygments", "kate", "monochrome", "espresso", "zenburn", and "haddock" (specify null to prevent syntax    
    theme: default # theme specifies the Bootstrap theme to use for the page. Valid themes include default, cerulean, journal, flatly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, and yeti.
    df_print: tibble #options: default, tibble, paged

---

```{r, echo=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>", highlight = TRUE)
```

# Introduction

## Libraries we will use

Load packages:

```{r, message=FALSE}
library(tidyverse)
library(lubridate)
```

## Lecture overview

The **programming unit** will introduce you to tools that tell your computer to do the same or similar things over and over, without having to write the code over and over (e.g., iteration). And the code you write to do things over and over, will be able to do things differently depending on conditions of the data or depending on things you specify. 

Paraphrasing **Will Doyle**:

> "Computers love to do the same thing over and over. It's their favorite thing to do. Learn to make your computer happy."

The **3 core foci** of this unit are:

- Iteration (loops)
- Conditionals (if, if/else)
- Functions

But more than learning these things, this unit is about developing a more formal, rigorous understanding of programming concepts so that you can become a more powerful programmer. Towards that end, we will be reading chapters from Wickham's free text book [_Advanced R_](https://adv-r.hadley.nz/).

  
In fact, please spend 10 minutes reading the [Chapter 1](https://adv-r.hadley.nz/introduction.html) (sections 1.1 through 1.5)

# Foundational concepts

See [here](https://anyone-can-cook.github.io/rclass1/lectures/strings_dates_time/strings_dates_time.html#2_Data_structures_and_types) for a review of data structures and types.

## Subsetting elements

What is **subsetting**?

- Subsetting refers to isolating particular elements of an object 
- Subsetting operators can be used to select/exclude elements (e.g., variables, observations)
- There are three subsetting operators: `[]`, `[[]]`, `$` 
- These operators function differently based on vector types (e.g., atomic vectors, lists, dataframes)

<br>
For the examples in the next few subsections, we will be working with the following named atomic vector, named list, and dataframe:

- Create **named atomic vector** called `v` with 4 elements

    ```{r}
    v <- c(a = 10, b = 20, c = 30, d = 40)
    v
    ```

- Create **named list** called `l` with 4 elements

    ```{r}
    l <- list(a = TRUE, b = c("a", "b", "c"), c = list(1, 2), d = 10L)
    l
    ```

- Create **dataframe** called `df` with 4 columns and 3 rows

    ```{r}
    df <- data.frame(
      a = c(11, 21, 31),
      b = c(12, 22, 32),
      c = c(13, 23, 33),
      d = c(14, 24, 34)
    )
    df
    ```

<br>
    
### Subsetting using `[]`

The `[]` operator:

- Subsetting an object using `[]` returns an object of the same type
  - E.g., Using `[]` on an atomic vector returns an atomic vector, using `[]` on a list returns a list, etc.
- The returned object will contain the element(s) you selected
- Object attributes are retained when using `[]` (e.g., _name_ attribute)

**Six ways** to subset using `[]`:

1. Use positive integers to return elements at specified index positions
2. Use negative integers to exclude elements at specified index positions
3. Use logical vectors to return elements where corresponding logical is `TRUE`
4. Empty vector `[]` returns original object (useful for dataframes)
5. Zero vector `[0]` returns empty object (useful for testing data)
6. If object is named, use character vectors to return elements with matching names

<br>
<details><summary>**Example**: Using positive integers with `[]`</summary>

**Selecting a single element**: Specify the index of the element to subset

```{r}
# Select 1st element from numeric vector (note that `names` attribute is retained)
v[1]

# Subsetted object will be of type `numeric`
class(v[1])

# Select 1st element from list (note that `names` attribute is retained)
l[1]

# Subsetted object will be a `list` containing the element
class(l[1])
```

<br>
**Selecting multiple elements**: Specify the indices of the elements to subset using `c()`

```{r}
# Select 3rd and 1st elements from numeric vector
v[c(3,1)]

# Subsetted object will be of type `numeric`
class(v[c(3,1)])

# Select 1st element three times from list
l[c(1,1,1)]

# Subsetted object will be a `list` containing the elements
class(l[c(1,1,1)])
```

</details>

<br>
<details><summary>**Example**: Using negative integers with `[]`</summary>

**Excluding a single element**: Specify the index of the element to exclude

```{r}
# Exclude 1st element from numeric vector
v[-1]

# Subsetted object will be of type `numeric`
class(v[-1])
```

<br>
**Excluding multiple elements**: Specify the indices of the elements to exclude using `-c()`

```{r}
# Exclude 1st and 3rd elements from list
l[-c(1,3)]

# Subsetted object will be a `list` containing the remaining elements
class(l[-c(1,3)])
```

</details>

<br>
<details><summary>**Example**: Using logical vectors with `[]`</summary>

If the logical vector is the same length as the object, then each element in the object whose corresponding position in the logical vector is `TRUE` will be selected:

```{r}
v
# Select 2nd and 3rd elements from numeric vector
v[c(FALSE, TRUE, TRUE, FALSE)]

# Subsetted object will be of type `numeric`
class(v[c(FALSE, TRUE, TRUE, FALSE)])
```

<br>
If the logical vector is shorter than the object, then the elements in the logical vector will be recycled:

```{r}
# This is equivalent to `l[c(FALSE, TRUE, FALSE, TRUE)]`, thus retaining 2nd and 4th elements
l[c(FALSE, TRUE)]

# Subsetted object will be a `list` containing the elements
class(l[c(FALSE, TRUE)])
```

<br>
We can also write expressions that evaluate to either `TRUE` or `FALSE`:

- this is the sort of stuff we do when we filter observations based on variable values (e.g., show me the observations where the statement `var1>=30` is `TRUE` )
```{r}
# This expression is recycled and evaluates to be equivalent to `l[c(FALSE, FALSE, TRUE, TRUE)]`
v[v > 20]
```

</details>

<br>
<details><summary>**Example**: Using empty vector `[]`</summary>

An empty vector `[]` just returns the original object:

```{r}
# Original atomic vector
v[]

# Original list
l[]

# Original dataframe
df[]
```

</details>

<br>
<details><summary>**Example**: Using zero vector `[0]`</summary>

A zero vector `[0]` just returns an empty object of the same type as the original object:

```{r}
# Empty named atomic vector
v[0]

# Empty named list
l[0]

# Empty dataframe
df[0]
```

</details>

<br>
<details><summary>**Example**: Using element names with `[]`</summary>

We can select a single element or multiple elements by their name(s):

```{r}
# Equivalent to v[2]
v["b"]

# Equivalent to l[c(1, 3)]
l[c("a", "c")]
```

</details>
<br>

### Subsetting using `[[]]`

The `[[]]` operator:

- We can only use `[[]]` to extract a single element rather than multiple elements
- Subsetting an object using `[[]]` returns the selected element itself, which might not be of the same type as the original object
  - E.g., Using `[[]]` to select a list element that is a numeric vector will return that numeric vector and not a list containing that numeric vector, like what `[]` would return
    - Let `x` be a list with 3 elements (_Think of it as a train with 3 cars_)
    ![](https://d33wubrfki0l68.cloudfront.net/1f648d451974f0ed313347b78ba653891cf59b21/8185b/diagrams/subsetting/train.png)
    - `x[1]` will be a list containing the 1st element, which is a numeric vector (i.e., _train with the 1st car_)
    - `x[[1]]` will be the numeric vector itself (i.e., _the objects within the 1st car_)
    ![](https://d33wubrfki0l68.cloudfront.net/aea9600956ff6fbbc29d8bd49124cca46c5cb95c/28eaa/diagrams/subsetting/train-single.png)
    - *Source: Subsetting from [R for Data Science](https://adv-r.hadley.nz/subsetting.html)*
- Object attributes are removed when using `[[]]`
  - E.g., Using `[[]]` on a named object returns just the selected element itself without the name attribute

<br>
**Two ways** to subset using `[[]]`:

1. Use a positive integer to return an element at the specified index position
2. If object is named, using a character to return an element with the specified name

<br>
<details><summary>**Example**: Using positive integer with `[[]]`</summary>

```{r}
# Select 1st element from numeric vector (note that `names` attribute is gone)
v[[1]]

# Subsetted element is `numeric`
class(v[[1]])

# Select 1st element from list (note that `names` attribute is gone)
l[[1]]

# Subsetted element is `logical`
class(l[[1]])
```

</details>

<br>
<details><summary>**Example**: Using element name with `[[]]`</summary>

```{r}
# Equivalent to v[[2]]
v[["b"]]

# Subsetted element is `numeric`
class(v[["b"]])

# Equivalent to l[[2]]
l[["b"]]

# Subsetted element is `character` vector
class(l[["b"]])
```

</details>
<br>

### Subsetting using `$`

The `$` operator:

- `obj_name$element_name` is shorthand for `obj_name[["element_name"]]`
- This operator only works on lists (including dataframes) and not on atomic vectors

<br>
<details><summary>**Example**: Subsetting with `$`</summary>

Subsetting a list with `$`:

```{r}
# Equivalent to l[["b"]]
l$b

# Subsetted element is `character` vector
class(l$b)
```

<br>
Since dataframes are just a special kind of named list, it would work the same way:

```{r}
# Equivalent to df[["d"]]
df$d
```

</details>
<br>

### Subsetting dataframes

Subsetting dataframes with `[]`, `[[]]`, and `$`:

- Subsetting dataframes works the same way as lists because dataframes are just a special kind of named list, where we can think of each element as a column
  - `df_name[<column(s)>]` returns a dataframe containing the selected column(s), with its attributes retained
  - `df_name[[<column>]]` or `df_name$<column>` returns the column itself, without any attributes
- In addition to the normal way of subsetting, we are also allowed to subset dataframes by cell(s)
  - `df_name[<row(s)>, <column(s)>]` returns the selected cell(s)
    - If a single cell is selected, or cells from the same column, then these would be returned as an object of the same type as that column (similar to how `[[]]` normally works)
    - Otherwise, the subsetted object would be a dataframe, as we'd normally expect when using `[]`
  - `df_name[[<row>, <column>]]` returns the selected cell
    - This is equivalent to selecting a single cell using `df_name[<row(s)>, <column(s)>]`

<br>
<details><summary>**Example**: Subsetting dataframe column(s) with `[]`</summary>

We can subset dataframe column(s) the same way we have subsetted atomic vector or list element(s):

```{r}
df

# Select 1st column from dataframe (note that `names` attribute is retained)
df[1]

# Subsetted object will be a `data.frame` containing the column
class(df[1])

# Exclude 1st and 3rd columns from dataframe (note that `names` attribute is retained)
df[-c(1,3)]

# Subsetted object will be a `data.frame` containing the remaining columns
class(df[-c(1,3)])
```

</details>

<br>
<details><summary>**Example**: Subsetting dataframe column with `[[]]` and `$`</summary>

We can select a single dataframe column the same way we have subsetted a single atomic vector or list element:

```{r}
# Select 1st column from dataframe by its index (note that `names` attribute is gone)
df[[1]]

# Subsetted column is `numeric` vector
class(df[[1]])

# Equivalently, we could've selected 1st column by its name
df[["a"]]

# Equivalently, we could've selected 1st column using `$`
df$a
```

</details>

<br>
<details><summary>**Example**: Subsetting dataframe cell(s) with `[]`</summary>

If we select a single cell by specifying its row and column, we will get back the element itself, not in a dataframe:

```{r}
# Selects cell in 1st row and 2nd col
df[1, 2]

# Subsetted cell is of type `numeric`
class(df[1, 2])

# Equivalently, we could select using column name instead of index
df[1, "b"]
```

<br>
Similarly, if we select cells from the same column, we will get back the elements themselves, not in a dataframe:

```{r}
# Selects cells from the 2nd col
df[c(1,3), 2]

# Subsetted cells is of type `numeric`
class(df[c(1,3), 2])

# Selects all cells from the 2nd col
df[, 2]

# Subsetted column is of type `numeric`
class(df[, 2])
```

<br>
However, if we select cells from the same row, or cells across multiple rows and columns, we will get back a dataframe that contains the selected cells:

```{r}
# Selects cells from the 2nd row
df[2, c("a", "c")]

# Subsetted cells are returned as a dataframe
class(df[2, c("a", "c")])

# Selects all cells from the 2nd row
df[2, ]

# Subsetted row is returned as a dataframe
class(df[2, ])

# Selects cells from multiple rows and columns
df[1:2, c("a", "c")]

# Subsetted cells are returned as a dataframe
class(df[1:2, c("a", "c")])
```

</details>

<br>
<details><summary>**Example**: Subsetting dataframe cell with `[[]]`</summary>

With `[[]]`, we are only allowed to select a single cell:

```{r}
# Selects cell in 1st row and 2nd col
df[[1, 2]]

# Subsetted cell is of type `numeric`
class(df[[1, 2]])

# This is equivalent to using `[]`
df[1, 2]
```

</details>
<br>

## Prerequisite concepts

Several functions and concepts are used frequently when creating loops and/or functions.

### Sequences

What are **sequences**?

- (Loose) definition: A **sequence** is a list of numbers in ascending or descending order
- Sequences can be created using the `:` operator or `seq()` function

**Example**: Creating sequences using `:`

```{r}
# Sequence from -5 to 5
-5:5

# Sequence from 5 to -5
5:-5
```

<br>
__The `seq()` function__:

```{r, eval = FALSE}
?seq

# SYNTAX AND DEFAULT VALUES
seq(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
    length.out = NULL, along.with = NULL, ...)
```

- Function: Generate a sequence
- Arguments
  - `from`: The starting value of sequence
  - `to`: The end (or maximal) value of sequence
  - `by`: Increment of the sequence

**Example**: Creating sequences using `seq()`

```{r}
# Sequence from 10 to 15, by increment of 1 (default)
seq(from=10, to=15)

# Explicitly specify increment of 1 (equivalent to above)
seq(from=10, to=15, by=1)

# Sequence from 100 to 150, by increment of 10
seq(from=100, to=150, by=10)
```

<br>

### Length

__The `length()` function__:

```{r, eval = FALSE}
?length

# SYNTAX
length(x)
```

- Function: Returns the number of elements in the object
- Arguments
  - `x`: The object to find the length of

<br>
**Example**: Using `length()` to find number of elements in `v`

```{r}
# View the atomic vector
v

# Use `length()` to find number of elements
length(v)
```

<br>
**Example**: Using `length()` to find number of elements in `df`

Remember that dataframes are just lists where each element is a column, so the number of elements in a dataframe is just the number of columns it has:

```{r}
# View the dataframe
df

# Use `length()` to find number of elements (i.e., columns)
length(df)
```

<br>
When we subset a dataframe using `[]` (i.e., _select column(s) from the dataframe_), the length of the subsetted object is the number of columns we selected:

```{r}
# Subset one column
df[1]

# Length is one
length(df[1])

# Subset three columns
df[1:3]

# Length is three
length(df[1:3])
```

<br>
When we subset a dataframe using `[[]]` (i.e., _isolate a specific column in the dataframe_), the length of the subsetted object is the number of elements in the atomic vector (i.e., the number of rows in the dataframe):

```{r}
# Isolate a specific column
df[[2]]

# Length is number of elements in that column (i.e., number of rows in dataframe)
length(df[[2]])
```

<br>

### Sequences and length

When writing loops, it is very common to create a sequence from 1 to the length (i.e., _number of elements_) of an object.

<br>
**Example**: Generating a sequence from 1 to length of `v`

```{r}
# There are 4 elements in the atomic vector
v
length(v)

# Use `:` to generate a sequence from 1 to 4
1:length(v)

# Use `seq()` to generate a sequence from 1 to 4
seq(1, length(v))
```

<br>
There is also a function `seq_along()` that makes it easier to generate a sequence from 1 to the length of an object.

<br>
__The `seq_along()` function__:

```{r, eval = FALSE}
?seq_along

# SYNTAX
seq_along(x)
```

- Function: Generates a sequence from 1 to the length of the input object
- Arguments
  - `x`: The object to generate the sequence for

<br>
**Example**: Generating a sequence from 1 to length of `df`

```{r}
# There are 4 elements (i.e., columns) in the dataframe
df

# Use `seq_along()` to generate a sequence from 1 to 4
seq_along(df)

# which is gives us the same thing as this:
1:length(df)
```


# Iteration

What is **iteration**?

- Iteration is the repetition of some process or operation
  - E.g., Iteration can help with "repeating the same operation on different columns, or on different datasets" (From [R for Data Science](https://r4ds.had.co.nz/iteration.html))
- Looping is the most common way to iterate

## Loop basics

What are **loops**?

- __Loops__ execute some set of commands multiple times
- Each time the loop executes the set of commands is an __iteration__
- The below loop iterates 4 times

<br>
__Example__: Printing each element of the vector `c(1,2,3,4)` using a loop

```{r}
# There are 4 elements in the vector
c(1,2,3,4)

# Iterate over each element of the vector
for(i in c(1,2,3,4)) {
  print(i)  # Print out each element
}
```

<br>
When to write **loops**?

- Broadly, rationale for writing loop:
  - Do not duplicate code
  - Can make changes to code in one place rather than many
- When to write a loop:
  - Grolemund and Wickham say __don't copy and paste more than twice__
  - If you find yourself doing this, consider writing a loop or function
- Don't worry about knowing all the situations you should write a loop
  - Rather, you'll be creating analysis dataset or analyzing data and you will notice there is some task that you are repeating over and over
  - Then you'll think, "Oh, I should write a loop or function for this"


## Components of a loop

How to write a **loop**?

- We can build loops using the `for()` function
- The **loop sequence** goes inside the parentheses of `for()`
- The **loop body** goes inside the pair of curly brackets (`{}`) that follows `for()`

```{r, eval=FALSE}
for(i in c(1,2,3,4)) {  # Loop sequence
  print(i)  # Loop body
}
```

<br>
Components of a **loop**:

1. __Sequence__: Determines what to "loop over"
    - In the above example, the sequence is `i in c(1,2,3,4)`
    - This creates a temporary/local object named `i` (could name it anything)
    - Each iteration of the loop will assign a different value to `i`
    - `c(1,2,3,4)` is the set of values that will be assigned to `i` 
        - In the first iteration, the value of `i` is `1`
        - In the second iteration, the value of `i` is `2`, etc.
2. __Body__: What commands to execute for each iteration of the loop
    - In the above example, the body is `print(i)`
    - Each time through the loop (i.e., _iteration_), body prints the value of object `i`
    

### Ways to write loop sequence

You may see the **loop sequence** being written in slightly different ways. For example, these three loops all do the same thing:

- Looping over the vector `c(1,2,3)`

    ```{r}
    c(1,2,3)
    
    for(z in c(1,2,3)) {  # Loop sequence
      print(z)  # Loop body
    }
    ```

- Looping over the sequence `1:3` 

    ```{r}
    1:3
    
    for(z in 1:3) {  # Loop sequence
      print(z)  # Loop body
    }
    ```

- Looping over the object `num_sequence`
    
    ```{r}
    num_sequence <- 1:3
    num_sequence
    
    for(z in num_sequence) {  # Loop sequence
      print(z)  # Loop body
    }
    ```

### Printing values in loop body

When building a loop, it is useful to print out information to understand what the loop is doing.

- __In my opinion, the MOST IMPORTANT tool for learning how to write loops (and how to write functions) is knowing how to print out the value of the object(s) associated with each iteration__


Using `print()` to print a single object `z`

- Using `print()` to show the value of object(s) within an iteration is not best approach because
  - `print()` can only print one object per line
  - `print()` can't include additional text that tells you what stuff is
    ```{r}
    for(z in c(1,2,3)) {
      print(z)
    }
    ```
    
 
 <br>
 
__The best way to print object(s) associated with each iteration is wrapping the `str_c()` function within the `writeLines()` function__. 

- recommend spending a few minutes reviewing `str_c()` function
  - help: `?str_c`
  - See section on `str_c` from "Intro to strings, dates, and time" lecture of Rclass1 [LINK HERE](https://anyone-can-cook.github.io/rclass1/lectures/strings_dates_time/strings_dates_time.html#42_str_c())
- Why wrap `str_c()` within `writeLines()`?:
  - within a loop body (or function body),`str_c()` function by itself will not print output
  - `writeLines(str_c(...))` forces whatever is returned by `str_c()` to be printed


- Using `str_c()` and `writeLines()` to concatenate and print multiple items
  - within a loop body or function body, in order to print output returned by `str_c()` you must wrap `str_c()` within `writeLines()` function
    ```{r}
    for(z in c(1,2,3)) {
      writeLines(str_c("object z=", z))
    }
    ```
<br><br>

- _Note_: Using `writeLines()` by itself to print a single object `z` (code not run); this approach won't work because `writeLines` can only write character objects

```{r, eval = FALSE}
    for(z in c(1,2,3)) {
      writeLines(z)
    }
```

- - _Note_: Using `str_c()` without wrapping in `writeLines()` 
  - `str_c()` function that is within a loop body (or function body) will not print output
    ```{r}
    for(z in c(1,2,3)) {
      str_c("object z=", z)
    }
    ```
    

### Student exercise


1. Create a numeric vector that contains the birth years of your family members
    - E.g., `birth_years <- c(1944,1950,1981,2016)`
2. Write a loop that calculates the current year minus birth year and prints this number for each member of your family
    - Within this loop, you will create a new variable that calculates current year minus birth year

<br>
<details><summary>**Solutions**</summary>

```{r}
birth_years <- c(1944,1950,1981,2016,2019)
birth_years

for(y in birth_years) {  # Loop sequence
  writeLines(str_c("object y=", y))  # Loop body
  z <- 2023 - y
  writeLines(str_c("value of 2023 minus ", y, " is ", z))
}
```
</details>


## Ways to loop over a vector

There are 3 ways to loop over elements of an object:

1. [Looping over the element (contents)](#looping-over-elements) (approach we have used so far)
2. [Looping over names of the elements](#looping-over-names)
3. [Looping over numeric indices associated with element position](#looping-over-indices) (approach recommended by Grolemnund and Wickham)

<br>
For the examples in the next few subsections, we will be working with the following named atomic vector and dataframe:

- Create named atomic vector called `vec`

    ```{r}
    vec <- c(a = 5, b = -10, c = 30)
    vec
    ```
  - element (contents) are: `r c(v[[1]],v[[2]],v[[3]])`
  - element names are: `r names(vec)`
  - indices of element position are: `r 1:length(vec)`

- Create dataframe called `df` with randomly generated data, 3 columns (vars) and 4 rows (obs)

    ```{r}
    set.seed(12345) # so we all get the same variable values
    df <- tibble(a = rnorm(4), b = rnorm(4), c = rnorm(4))
    str(df)
    ```

### Looping over elements

**Syntax**: `for (i in object_name)`

- This approach iterates over each element in the object
- The value of `i` is equal to the element's _content_ (rather than its _name_ or _index position_)

<br>
**Example**: Looping over elements in `vec`
    
```{r}
vec  # View named atomic vector object

for (i in vec) {
  writeLines(str_c("value of object i=",i))
  writeLines(str_c("object i has: type=", typeof(i), "; length=", length(i), "; class=", class(i), "\n"))  # "\n" adds line break
}
```

<br>
**Example**: Looping over elements in `df`

```{r}
df  # View dataframe object

# show contents of element, outside of a loop
  # each element of the dataframe is a vector that contains one element for each observation
  str(df[1]) # single bracket
  str(df[[1]]) # double bracket

for (i in df) {
  writeLines(str_c("value of object i=",i))
  writeLines(str_c("object i has: type=", typeof(i), "; length=", length(i), "; class=", class(i), "\n"))  # "\n" adds line break
}
```

<br>
<details><summary>**Example**: Calculating column averages for `df` by looping over columns</summary>

<br>
The dataframe `df` is a list object, where each element is a vector (i.e., column):

```{r}
df  # View dataframe object

for (i in df) {
  writeLines(str_c("value of object i=", i))
  writeLines(str_c("mean value of object i=", mean(i, na.rm = TRUE), "\n"))
}
```
</details>

### Looping over names

**Syntax**: `for (i in names(object_name))`

- To use this approach, elements in the object must have name attributes
- This approach iterates over the names of each element in the object
- `names()` returns a vector of the object's element names
- The value of `i` is equal to the element's _name_ (rather than its _content_ or _index position_)
- But note that it is still possible to access the element's content inside the loop:
    - Access element contents using `object_name[i]`
        - Same object type as `object_name`; retains attributes (e.g., _name_ attribute)
    - Access element contents using `object_name[[i]]`
        - Removes level of hierarchy, thereby removing attributes
        - Approach recommended by Wickham because it isolates value of element

<br>
**Example**: Looping over element names in `vec`

```{r}
vec  # View named atomic vector object
names(vec)  # View names of atomic vector object

for (i in names(vec)) {
  writeLines(str_c("\nvalue of object i=", i, "; type=", typeof(i)))
  #str(vec[i])  # Access element contents using []
  str(vec[[i]])  # Access element contents using [[]]
}
```

<br>
**Example**: Looping over elements in `df`

```{r}
df  # View dataframe object
names(df)  # View names of dataframe object (i.e., column names)

# show using name to print contents, outside of a loop
str(df["a"]) # single bracket
str(df[["a"]]) # double bracket

for (i in names(df)) {
  writeLines(str_c("\nvalue of object i=", i, "; type=", typeof(i)))
  #str(df[i])  # Access element contents using []
  str(df[[i]])  # Access element contents using [[]]
}
```


<br>
<details><summary>**Example**: Calculating column averages for `df` by looping over column names</summary>

```{r}
str(df)  # View structure of dataframe object
```

<br>
Remember that we can use `[[]]` to access element contents by their name:

```{r}
for (i in names(df)) {
  writeLines(str_c("mean of element named ", i, " = ", mean(df[[i]], na.rm = TRUE)))
}
```

<br>
If we tried completing the task using `[]` to access the element contents, we would get an error because `mean()` only takes numeric or logical vectors as input, and `df[i]` returns a dataframe object:

```{r, eval=FALSE}
for (i in names(df)) {
  writeLines(str_c("mean of element named", i, "=", mean(df[i], na.rm = TRUE)))
  
  # print(class(df[i]))
}
```

</details>

### Looping over indices


**Syntax**: `for (i in 1:length(object_name))` OR `for (i in seq_along(object_name))`

- This approach iterates over the index positions of each element in the object
- There are two ways to create the loop sequence:
    - `length()` returns the number of elements in the input object, which we can use to create a sequence of index positions (i.e., `1:length(object_name)`)
    - `seq_along()` returns a sequence of numbers that represent the index positions for all elements in the input object (i.e., equivalent to `1:length(object_name)`)
- The value of `i` is equal to the element's _index position_ (rather than its _content_ or _name_)
- But note that it is still possible to access the element's content inside the loop:
    - Access element contents using `object_name[i]`
        - Same object type as `object_name`; retains attributes (e.g., _name_ attribute)
    - Access element contents using `object_name[[i]]`
        - Removes level of hierarchy, thereby removing attributes
        - Approach recommended by Wickham because it isolates value of element
- Similarly, we can access the element's name by its index using `names(object_name)[i]` or `names(object_name)[[i]]`
    - In this case, using `[[]]` and `[]` are equivalent because `names()` returns an unnamed vector, which does not have any attributes

<br>
**Example**: Looping over indices of `vec` element position

```{r}
vec  # View named atomic vector object
length(vec)  # View length of atomic vector object
1:length(vec)  # Create sequence from `1` to `length(vec)`

for (i in 1:length(vec)) {
  writeLines(str_c("\nvalue of object i=", i, "; type=", typeof(i)))
  #str(vec[i])  # Access element contents using []
  str(vec[[i]])  # Access element contents using [[]]
}
```



<br>
**Example**: Looping over elements in `df`

```{r}
df  # View dataframe object
seq_along(df)  # Equivalent to `1:length(df)`

for (i in seq_along(df)) {
  writeLines(str_c("\nvalue of object i=", i, "; type=", typeof(i)))
  str(df[i])  # Access element contents using []
  str(df[[i]])  # Access element contents using [[]]
}
```

<br>
We could also access the element's name by its index:

```{r}
names(df)  # View names of dataframe object (i.e., column names)
names(df)[[2]]  # We can access any element in the names vector by its index
   #names(df)[2]  # same as above

# Incorporate the above line into the loop
for (i in 1:length(df)) {
  writeLines(str_c("i=", i, "; name=", names(df)[[i]]))
}
```

<br>
<details><summary>**Example**: Calculating column averages for `df` by looping over column indices</summary>

<br>

Use `i in seq_along(df)` to loop over the column indices and `[[]]` to access column contents:

```{r}
str(df)  # View structure of dataframe object

for (i in seq_along(df)) {
  writeLines(str_c("mean of element at index position", i, "=", mean(df[[i]], na.rm = TRUE)))
}
```

</details>

### Summary

There are **3 ways** to loop over elements of an object:

1. [Looping over the elements](#looping-over-elements)
2. [Looping over names of the elements](#looping-over-names)
3. [Looping over numeric indices associated with element position](#looping-over-indices)
    - Grolemnund and Wickham recommends this approach (**#3**) because given an element's index position, we can also extract the element name (**#2**) and value (**#1**)


```{r}
for (i in seq_along(df)) {
  writeLines(str_c("\n", "i=", i))  # element's index position
  
  name <- names(df)[[i]]  # element's name (what we looped over in approach #2)
  writeLines(str_c("name=", name))
  
  value <- df[[i]]  # element's value (what we looped over in approach #1)
  writeLines(str_c("value=", value))
}
```


## Modifying vs. creating object

Grolemund and Wickham differentiate between **two types** of tasks loops accomplish:

1. __Modifying an existing object__
    - E.g., Looping through a set of variables in a dataframe to:
        - Modify these variables OR
        - Create new variables (within the existing dataframe object)
    - When writing loops in Stata/SAS/SPSS, we are usually modifying an existing object because these programs typically only have one object (a dataset) open at a time
2. __Creating a new object__
    - E.g., Creating an object that has summary statistics for each variable, which can be the basis for a table or graph, etc.
    - The new object will often be a vector of results based on looping through elements of a dataframe
    - In R (as opposed to Stata/SAS/SPSS), creating a new object is very common because R can hold many objects at the same time


### Modifying an existing object

How to modify an **existing object**?

- Recall that we can directly access elements in an object (e.g., atomic vector, lists) using `[[]]`. We can use this same notation to _modify_ the object.
- Even though atomic vectors can also be modified with `[]`, Wickhams recommends using `[[]]` in all cases to make it clear we are working with a single element (From [R for Data Science](https://r4ds.had.co.nz/iteration.html#modifying-an-existing-object))

<br>
<details><summary>**Example**: Modifying an existing atomic vector</summary>

Recall our named atomic vector `vec` from the previous examples:

```{r}
vec
```

We can loop over the index positions and use `[[]]` to modify the object:

```{r}
for (i in seq_along(vec)) {
  vec[[i]] <- vec[[i]] * 2  # Double each element
}

vec
```

</details>

<br>
<details><summary>**Example**: Modifying an existing dataframe</summary>

Recall our dataframe `df` from the previous examples:

```{r}
df
```

We can loop over the index positions and use `[[]]` to modify the object:

```{r}
for (i in seq_along(df)) {
  df[[i]] <- df[[i]] * 2  # Double each element
}

df
```

</details>


### Creating a new object

So far our loops have **two components**: 

1. Sequence
1. Body

When we create a **new object** to store the results of a loop, our loops have **three components**:

1. Sequence
1. Body
1. **Output** (_This is the new object that will store the results created from your loop_)

<br>
Grolemund and Wickham recommend using `vector()` to create this new object __prior__ to writing the loop (rather than creating the new object within the loop):

> "Before you start loop...allocate sufficient space for the output. This is very important for efficiency: if you grow the for loop at each iteration using `c()` (for example), your for loop will be very slow."

<br>
__The `vector()` function__:

```{r, eval = FALSE}
?vector

# SYNTAX AND DEFAULT VALUES
vector(mode = "logical", length = 0)
```

- Function: Creates a new vector object of the given length and mode
- Arguments
  - `mode`: Type of vector to create (e.g., `"logical"`, `"numeric"`, `"list"`)
  - `length`: Length of the vector

<br>
<details><summary>**Example**: Creating a new object to store dataframe column averages</summary>

Recall the previous example where we calculated the mean value of each column in dataframe `df`:

```{r}
str(df)

for (i in seq_along(df)) {
  writeLines(str_c("mean of element at index position", i, "=", mean(df[[i]], na.rm = TRUE)))
}
```

<br>
Let's create a new object to store these column averages. Specifically, we'll create a new numeric vector whose length is equal to the number of columns in `df`:

```{r}
output <- vector(mode = "numeric", length = length(df))

output # print
class(output)  # Specified by `mode` argument in `vector()`
length(output)  # Specified by `length` argument in `vector()`
```

<br>
We can loop over the index positions of `df` and use `[[]]` to modify `output`:

```{r}
for (i in seq_along(df)) {
  output[[i]] <- mean(df[[i]], na.rm = TRUE)  # Mean of df[[1]] assigned to output[[1]], etc.
}

output
```

</details>

## Summary

The general recipe for how to write a loop:

1. Complete the task for one instance outside a loop (this is akin to writing the __body__ of the loop)

2. Write the __sequence__ of the loop

3. Modify the parts of the loop body that need to change with each iteration

4. _If_ you are creating a new object to store output of the loop, create this object outside of the loop

5. Construct the loop

<br>
<details><summary>**When to write a loop vs a function**</summary>

It's usually obvious when you are duplicating code, but unclear whether you should write a loop or whether you should write a function.

- Often, a repeated task can be completed with a loop or a function

In my experience, loops are better for repeated tasks when the individual tasks are __very__ similar to one another

- E.g., a loop that reads in datasets from individual years; each dataset you read in differs only by directory and name
- E.g., a loop that converts negative values to `NA` for a set of variables

Because functions can have many arguments, functions are better when the individual tasks differ substantially from one another 

- E.g., a function that runs regression and creates formatted results table
    - Function allows you to specify (as function arguments): dependent variable; independent variables; what model to run, etc.

__Note__:

- Can embed loops within functions; can call functions within loops
- But for now, just try to understand basics of functions and loops

</details>


# Conditional execution

What is **conditional execution**?

- a **condition** is some statement that evaluates to either `TRUE` or `FALSE`; for example `1>5` evaluates to `FALSE`
- **Conditional execution** is the running of specific blocks of code based on some **condition**
  - E.g., If the number is even, run this block of code. Otherwise, run the other block of code, etc.
- We can write `if`, `else if`, and `else` statements to run code conditionally (covered in upcoming sections)
- This is useful because it allows for decision-making in the code

![](https://media.geeksforgeeks.org/wp-content/uploads/decision-making-c-4.png){width=500px}

*Credit: [Decision Making in C / C++](https://www.geeksforgeeks.org/decision-making-c-c-else-nested-else/), GeeksforGeeks*

## Conditions

What is a **condition**?

- A condition is any expression that can evaluate to `TRUE` or `FALSE`
- Your condition should have a length of `1` (otherwise R will warn you that it'll only look at the first element)
- Based on the condition, different blocks of your code will be run

<br>
Any expression that has a length of `1` and can evaluate to either `TRUE` or `FALSE` can be used as the condition:

```{r}
# This expression evaluates to `TRUE`
2 + 2 == 4

# It is of type `logical`
typeof(2 + 2 == 4)

# It has length of `1`
length(2 + 2 == 4)
```

Some functions return a `logical`, so you might also see a function call being used as the condition:

```{r}
# This function call returns `FALSE` because the string "NA" is not the missing value `NA`
is.na("NA")

# It is of type `logical`
typeof(is.na("NA"))

# It has length of `1`
length(is.na("NA"))

```

## `if` statement conditions

What are **`if` statement conditions**?

- `if` statements allow you to conditionally execute certain blocks of code depending on whether some condition(s) is `TRUE`
- The condition goes inside of the parentheses in `if()` and the block of code to execute goes between the curly brackets (`{}`)
- The condition must evaluate to either `TRUE` or `FALSE` (i.e., be of type `logical`)
- The condition should have length of `1`

```{r, eval=FALSE}
if (condition) {
  # code executed when condition is TRUE
}
```

<br>
The block of code is executed if the condition evaluates to `TRUE`:

```{r}
if (TRUE) {
  writeLines("This block is executed.")
}
```

note that below block of code yields the exact same result as above because the condition evaluates to `TRUE`
```{r}
if (1==1) {
  writeLines("This block is executed.")
}
```

The block of code is not executed if the condition evaluates to `FALSE`:

```{r}
if (FALSE) {
  writeLines("This block is not executed.")
}
```

<br>
<details><summary>**Example**: Condition that evaluates to `TRUE`</summary>

Remember that any expression that has a length of `1` and can evaluate to either `TRUE` or `FALSE` can be used as the condition:

```{r}
# This expression evaluates to `TRUE`
2 + 2 == 4

# It is of type `logical`
typeof(2 + 2 == 4)

# It has length of `1`
length(2 + 2 == 4)

# We can use it as the if statement condition
if (2 + 2 == 4) {
  writeLines("This block is executed because `2 + 2 == 4` evaluates to `TRUE`.")
}
```

</details>

<br>
<details><summary>**Example**: Condition that evaluates to `FALSE`</summary>

Recall that some functions return a `logical`, so you might also see a function call being used as the condition:

```{r}
# This function call returns `FALSE` because the string "NA" is not the missing value `NA`
is.na("NA")

# It is of type `logical`
typeof(is.na("NA"))

# It has length of `1`
length(is.na("NA"))

# We can use it as the if statement condition
if (is.na("NA")) {
  writeLines("This block is not executed because the condition evaluates to `FALSE`.")
}

# double negative equals positive!
if (!is.na("NA")) {
  writeLines("This block is not not executed because `!FALSE` evaluates to `TRUE`!")
}
```

</details>

### `||` and `&&`

How to combine **multiple logical expressions** in a condition?

- Recall that a **logical expression** is of type `logical` and has a length of `1`
- An `if` statement condition can be made up of multiple logical expressions
- We can use `||` (or) and `&&` (and) to combine multiple logical expressions
- "Never use `|` or `&` in an if statement: these are _vectorised_ operations that apply to multiple values (that's why you use them in `filter()`)" (From [R for Data Science](https://r4ds.had.co.nz/functions.html#conditional-execution))
    - Vectorised operations apply to each respective elements of the vectors and returns a vector:
        ```{r}
        c(TRUE, TRUE, FALSE) | c(TRUE, FALSE, FALSE)
        ```
        - 1st element of each vector: `TRUE` or `TRUE` is `TRUE`
        - 2nd element of each vector: `TRUE` or `FALSE` is `TRUE`
        - 3rd element of each vector: `FALSE` or `FALSE` is `FALSE`
    - Whereas `||` and `&&` will only look at the first element of each vector:
        ```{r}
        c(TRUE, TRUE, FALSE) || c(TRUE, FALSE, FALSE)
        ```

<br>
When using `||` (or), the block of code is executed if any of the conditions evaluates to `TRUE`:

```{r, eval=FALSE}
if (condition1 || condition2 || condition3) {
  # code executed when any of the conditions is TRUE
}
```

When using `&&` (and), the block of code is executed if all of the conditions evaluate to `TRUE`:

```{r, eval=FALSE}
if (condition1 && condition2 && condition3) {
  # code executed when all of the conditions are TRUE
}
```

<br>
<details><summary>**Example**: Combining multiple logical expressions using `||`</summary>

When using `||` (or), the block of code is executed if any of the conditions evaluates to `TRUE`:

```{r}
# This block is executed because at least 1 condition is `TRUE`
if (TRUE || FALSE) {
  writeLines("This block is executed.")
}

# This block is not executed because both logical expressions evaluate to `FALSE`
if (is.na("NA") || 2 + 2 == 5) {
  writeLines("This block is not executed.")
}
```

</details>

<br>
<details><summary>**Example**: Combining multiple logical expressions using `&&`</summary>

When using `&&` (and), the block of code is executed if all of the conditions evaluate to `TRUE`:

```{r}
# This block is not executed because not all conditions are `TRUE`
if (TRUE && FALSE) {
  writeLines("This block is not executed.")
}

# This block is executed because all logical expressions evaluate to `TRUE`
if (!is.na("NA") && 2 + 2 == 4) {
  writeLines("This block is executed.")
}
```

</details>

## `else` statements

What are **`else` statements**?

- After the `if` block, you can include an `else` block that will be executed if the `if` block did not execute
- In other words, the `else` block is executed if the `if` statement's condition is not met

```{r, eval=FALSE}
if (condition) {
  # code executed when condition is TRUE
} else {
  # code executed when condition is FALSE
}
```

<br>
<details><summary>**Example**: Using if-else statement</summary>

Recall the function [`dir.exists()`](https://anyone-can-cook.github.io/rclass2/lectures/organizing_and_io/organizing_and_io.html#244_Checking_if_filedirectory_exists) that checks if a directory exists:

```{r}
getwd()
list.files()

directory <- "my_new_directory"
dir.exists(directory)
```

<br>
Let's take a look at using an if-else statement to create the directory (using [`dir.create()`](https://anyone-can-cook.github.io/rclass2/lectures/organizing_and_io/organizing_and_io.html#243_Creating_directories)) only if it doesn't currently exist:

```{r}
if (dir.exists(directory)) {
  writeLines(str_c("The directory '", directory, "' already exists."))
} else {
  dir.create(directory)
  writeLines(str_c("Created directory '", directory, "'."))
}

# Check that directory is created
list.files()
```

<br>
If we try running this code again, the `if` block would be executed because the directory already exists:

```{r}
dir.exists(directory)

if (dir.exists(directory)) {
  writeLines(str_c("The directory '", directory, "' already exists."))
} else {
  dir.create(directory)
  writeLines(str_c("Created directory '", directory, "'."))
}
```

```{r, echo=FALSE}
# Delete directory
unlink(directory, recursive = TRUE)
```

</details>

<br>
<details><summary>**Example**: Using if-else statement with loop</summary>

We can loop over multiple directory names and for each, create the directory only if it does not already exist:

```{r}
directories <- c("scripts", "dictionaries", "output")
directories

for (i in directories) {
  if (dir.exists(i)) {
    writeLines(str_c("The directory '", i, "' already exists."))
  } else {
    dir.create(i)
    writeLines(str_c("Created directory '", i, "'."))
  }
}

# Check that directories are created
list.files()
```

<br>
If we try running the code again, the `if` block would be executed during each iteration of the loop because all the directories already exist:

```{r}
for (i in directories) {
  if (dir.exists(i)) {
    writeLines(str_c("The directory '", i, "' already exists."))
  } else {
    dir.create(i)
    writeLines(str_c("Created directory '", i, "'."))
  }
}
```

```{r, echo=FALSE}
# Delete directories
unlink(directories, recursive = TRUE, force = TRUE)
```

</details>

## `else if` statements

What are **`else if` statements**?

- Between the `if` blocks and `else` blocks, you can include additional block(s) using `else if` that gets executed if its condition is met and none of the previous blocks got executed
- In other words, only 1 block will ever execute in an `if`/`else if`/`else` chain

```{r, eval=FALSE}
if (condition) {
  # run this code if condition TRUE
} else if (condition) {
  # run this code if previous condition FALSE and this condition TRUE
} else if (condition) {
  # run this code if both previous conditions FALSE and this condition TRUE
} else {
  # run this code if all previous conditions FALSE
}
```

<br>
<details><summary>**Example**: Using `else if` statement</summary>

Using the `diamonds` dataset available from `ggplot2` (part of `tidyverse`), let's create a vector of 5 diamond prices:

```{r}
prices <- unique(diamonds$price)[23:27]
str(prices)
```

<br>
Let's loop through the `prices` vector and print whether each is affordable (under \$500), pricey (between \$500 and \$1000), or too expensive (\$1000 and up):

```{r}
for (i in prices) {
  if (i < 500) {
    writeLines(str_c("This diamond costs $", i, " and is affordable."))
  } else if (i >= 500 && i < 1000) {
    writeLines(str_c("This diamond costs $", i, " and is pricey..."))
  } else {
    writeLines(str_c("This diamond costs $", i, " and is too expensive!"))
  }
}
```

<br>
Remember that each subsequent `else if` statement will only be considered if all previous blocks did not run (i.e., their conditions were not met). This means we can simplify `i >= 500 && i < 1000` to `i < 1000` in the `else if` condition:

```{r}
for (i in prices) {
  if (i < 500) {
    writeLines(str_c("This diamond costs $", i, " and is affordable."))
  } else if (i < 1000) {
    writeLines(str_c("This diamond costs $", i, " and is pricey..."))
  } else {
    writeLines(str_c("This diamond costs $", i, " and is too expensive!"))
  }
}
```
</details>

## Processing time

Especially when working with large datasets, the time it takes for your code to run can really add up, so it is important to look for ways to optimize code such that it runs most efficiently. We can use `system.time()` to measure how long it takes for some code to run.

__The `system.time()` function__:

```{r, eval = FALSE}
?system.time

# SYNTAX AND DEFAULT VALUES
system.time(expr, gcFirst = TRUE)
```

- Function: Returns CPU (and other) times that `expr` used
- Arguments
    - `expr`: Valid R expression to be timed

<br>
For the below examples, we'll use this numeric atomic vector called `prices` that is equal to the price of each diamond in the `diamonds` dataframe:

```{r}
prices <- diamonds$price
str(prices)  # 53,940 diamond prices
```

<br>
<details><summary>**Example**: Allocating sufficient space for output before loop</summary>

Let's take a look at an example of using a loop to calculate the z-score for each diamond price and storing the scores in a vector. First, we'll calculate the mean and standard deviation of the prices:

```{r}
m <- mean(prices, na.rm=TRUE)
s <- sd(prices, na.rm=TRUE)
```

<br>
**[Method 1]** Growing the vector inside the loop using `c()`

- "Whenever you use `c()`, `append()`, `cbind()`, `rbind()`, or `paste()` to create a bigger object, R must first allocate space for the new object and then copy the old object to its new home. If you’re repeating this many times, like in a for loop, this can be quite expensive." (From [Advanced R](http://adv-r.had.co.nz/Profiling.html#avoid-copies))

```{r}
z_prices <- c()

system.time(
  for (i in 1:length(prices)) {
    z_prices <- c(z_prices, (prices[i] - m)/s)
  }
)
```

<br>
**[Method 2]** Creating the output vector before loop (_Recommended_)

- "Before you start the loop, you must always allocate sufficient space for the output. This is very important for efficiency" (From [R for Data Science](https://r4ds.had.co.nz/iteration.html#for-loops))
- As seen, we can do that by first creating the `z_prices` object using `vector()` before the loop

```{r}
z_prices <- vector("double", length(prices))

system.time(
  for (i in 1:length(prices)) {
    z_prices[i] <- (prices[i] - m)/s
  }
)
```

</details>


<br>
<details><summary>**Example**: Vectorising your code</summary>

What does it mean to "vectorise your code"?

- "Vectorising is about taking a 'whole object' approach to a problem, thinking about vectors, not scalars." (From [Advanced R](http://adv-r.had.co.nz/Profiling.html#vectorise))
- Often, this means avoiding loops and using vectorised functions instead (e.g., use `if_else()` function instead of if-else statement inside a for loop)

To see the difference, let's look at the example of classifying diamond prices as affordable or expensive.

<br>
**[Method 1]** Using if-else statement inside a for loop

```{r}
output <- vector("character", length(prices))

system.time(
  for (i in 1:length(prices)) {
    if (i < 500) {
      output[i] <- str_c("This diamond costs $", prices[i], " and is affordable.")
    } else {
      output[i] <- str_c("This diamond costs $", prices[i], " and is too expensive!")
    }
  }
)
```

<br>
**[Method 2]** Using the vectorised `if_else()` function (_Recommended_)

```{r}
system.time(
  output <- if_else(prices < 500,
                   str_c("This diamond costs $", prices, " and is affordable."),
                   str_c("This diamond costs $", prices, " and is too expensive!")
                   )
)
```

</details>

<br>
<details><summary>**Example**: Using multiple `if` statements vs. `if`/`else if`/`else` statements</summary>

**[Method 1]** Using multiple `if` statements inside a for loop

- Look out for situations like the below where we can use `if`/`else if`/`else` statements instead of multiple `if` statements
- With multiple `if` statements, each of the `if` conditions need to be checked for every diamond price

```{r}
output <- vector("integer", length(prices))

system.time(
  for (i in 1:length(prices)) {
    if (i < 200) {
      output[i] <- 1
    } 
    if (i >= 200 && i < 400) {
      output[i] <- 2
    }
    if (i >= 400 && i < 600) {
      output[i] <- 3
    } 
    if (i >= 600 && i < 800) {
      output[i] <- 4
    }
    if (i >= 800 && i < 1000) {
      output[i] <- 5
    } 
    if (i >= 1000 && i < 1500) {
      output[i] <- 6
    }
    if (i >= 1500 && i < 2000) {
      output[i] <- 7
    }
    if (i >= 2000) {
      output[i] <- 8
    }
  }
)
```

<br>
**[Method 2]** Using `if`/`else if`/`else` statements inside a for loop

- With `if`/`else if`/`else` statements, not all conditions below will be checked (only up to when one of the blocks get executed)
- Thus, we see a reduction in the processing time compared to **Method 1** - this will be especially true the more `if` statements there are

```{r}
output <- vector("integer", length(prices))

system.time(
  for (i in 1:length(prices)) {
    if (i < 200) {
      output[i] <- 1
    } else if (i < 400) {
      output[i] <- 2
    } else if (i < 600) {
      output[i] <- 3
    } else if (i < 800) {
      output[i] <- 4
    } else if (i < 1000) {
      output[i] <- 5
    } else if (i < 1500) {
      output[i] <- 6
    } else if (i < 2000) {
      output[i] <- 7
    } else {
      output[i] <- 8
    }
  }
)
```

<br>
**[Method 3]** Using the vectorised `if_else()` function

- Note that using a vectorised function when possible would still be the fastest
- But there can be a "trade-off between code speed and code readability", as nested `if_else()` statements are hard to read (From [Efficient R programming](https://csgillespie.github.io/efficientR/performance.html))

```{r}
system.time(
  output <- ifelse(prices < 200, 1, ifelse(prices < 400, 2, ifelse(prices < 600, 3, 
                   ifelse(prices < 800, 4, ifelse(prices < 1000, 5, ifelse(prices < 1500, 6, 
                   ifelse(prices < 2000, 7, 8)))))))
)
```

</details>


# Functions

## What are functions

What are **functions**?

- **Functions** are pre-written bits of code that accomplish some task
- Functions allow you to "automate" tasks that you perform more than once
- We can call functions whenever we want to use them, again and again

Functions generally follow **three sequential steps**:

1. Take in __input__ object(s)
2. __Process__ the input
3. __Return__ a new object, which may be a vector, data-frame, plot, etc.


### Functions from packages written by others

We've been working with functions all quarter. 

<br>
__Example__: The `sum()` function

```{r, eval = FALSE}
?sum
```

1. __Input__: Takes in a vector of elements (_class_ must be `numeric` or `logical`)
2. __Processing__: Calculates the sum of elements
3. __Return__: Returns a numeric vector of length `1` whose value is the sum of the input vector
    - You can use `str()` to investigate the return value of the function

```{r}
# Apply sum() to atomic vector
sum(c(1,2,3))
sum(c(1,2,3)) %>% str()
```

### User-written functions

What are "__user-written functions__"? [_my term_]

- __User-written functions__ are functions _you_ write to perform some specific task
- It can often be for a data-manipulation or analysis task specific to your project

Like all functions, user-written functions usually follow **three steps**:


1. Take in one or more __input__ object(s)
2. __Process__ the input
    - This may include utilizing existing functions from other packages, for example `sum()` or `length()`
3. __Return__ a new object

<br>
Can think of user-written functions as anologous to **mathematical functions** that take one or more input variables

- below, create function `f_xy` that takes two input variables: `x` and `y`
```{r}
f_xy <- function(x,y) {
  # function body
  x^2 + y
}

f_xy(x=2,y=2)
f_xy(x=3,y=1)

#what the function returns
f_xy(x=3,y=1) %>% str() # a numeric atomic vector of length 1

# assign the output of function to an object
z <- f_xy(x=3,y=1)
z
```
<br>

**Examples** of what we might want to write a function for:

- Write a function to read in annual data, then call function for each year
- Create interactive maps. e.g., see maps from policy report on [off-campus recruiting by public research universities](https://www.thirdway.org/report/follow-the-money-recruiting-and-the-enrollment-priorities-of-public-research-universities)
    - Link to maps [HERE](https://cyouh95.github.io/third-way-report/assets/maps/map_income.html)
    - R code for interactive maps developed by Karina Salazar, modified by Crystal Han
- [Ben Skinner](https://github.com/btskinner) recommends [paraphrasing] writing "short functions that do one thing and do it well"
    
<br>
__When to write a function__?

- Since functions are _reusable_ pieces of code, they allow you to "automate" tasks that you perform more than once
  - E.g., Check to see if IPEDS data file is already downloaded. If not, then download the data.
  - E.g., Write function that runs regression model and creates results table
- The alternative to writing a function to perform some specific task (aside from loops/iteration) is to copy and paste the code each time you want to perform a task
- [Wickham and Grolemund chapter 19.2](https://r4ds.had.co.nz/functions.html#when-should-you-write-a-function):

  > "You should consider writing a function whenever you’ve copied and pasted a block of code more than twice"
  
- Darin Christenson (professor, UCLA public policy) refers to the programming mantra __DRY__ ("Don't Repeat Yourself")

  > "Functions enable you to perform multiple tasks (that are similar to one another) without copying the same code over and over"

<br>
__Why write functions to complete a task__? (_as opposed to the copy-and-paste approach_)

- As task requirements change (and they always do!), you only need to revise code in one place rather than many places
- Reduce errors that are common in copy-and-paste approach (e.g., forgetting to change variable name or variable value)
- Functions give you an opportunity to make continual improvements to completing a task
    - E.g., you realize your function does not work for certain input values, so you modify function to handle those values

<br>
__How to approach writing functions__? (_broad recipe_)

1. Experiment with performing the task outside of a function
    - Experiment with performing task with different sets of inputs
    - Often, you must revise this code, when an approach that worked outside a function does not work within a function
1. Write the function
1. Test the function
    - Try to "break" it
1. __Continual improvement__. As you use the function, make continual improvements going back-and-forth between steps 1-3

## Basics of writing functions

Often, the functions we write will utilize existing functions from Base R and other R packages. For example, create a function named `z_score()` that calculates how many standard deviations an observation is from the mean. Our `z_score()` function will use the existing Base R `mean()` and `sd()` functions.

We will avoid creating user-written functions that utilize `Tidyverse` functions, particularly functions from the `dplyr` package such as `group_by()`. The reason is that including certain `Tidyverse`/`dplyr` functions in a user-written function requires knowledge of some advanced programming skills that we have not introduced yet. For more explanation, see [here](https://www.r-bloggers.com/data-frame-columns-as-arguments-to-dplyr-functions/) and [here](https://adv-r.hadley.nz/quasiquotation.html#unquoting). 

Therefore, when teaching how to write functions that perform data manipulation tasks, we will use a "Base R approach" rather than a "Tidyverse approach."

### Components of a function

The `function()` function tells R that you are writing a function:

```{r, eval=FALSE}
# To find help file for function():
  ?`function` # But help file is not a helpful introduction


function_name <- function(arg1, arg2, arg3) {
  # function body
}
```

**Three components** of a function:

1. __Function name__
    - Define a function using `function()` and give it a **name** using the assignment operator `<-`
2. __Function arguments__ (sometimes called "inputs")
    - Inputs that the function takes; they go inside the parentheses of `function()`
      - Can be vectors, data frames, logical statements, strings, etc.
    - In the above hypothetical code, the function took three inputs `arg1`, `arg2`, `arg3`, but we could have written:
      - `function(x, y, z)` or `function(Larry, Curly, Moe)`
    - In the "function call," you specify values to assign to these function arguments
3. __Function body__
    - What the function does to the inputs
    - Function body goes inside the pair of curly brackets (`{}`) that follows `function()`
    - Above hypothetical function doesn't do anything, but your function can **return a value** (covered in [later section](#return-values))

### `print_hello()` function

__Task__: Write function called `print_hello()` that prints `"Hello, world."`

```{r, echo=-c(1:2)}
print_hello <- function() {
  "Hello, world"
}

# Expected output
print_hello()
```

<details><summary>**Step 1**: Perform task outside of function</summary>

We want to print `"Hello, world"`:

```{r}
"Hello, world"
```

<br>
Alternative approaches to perform task outside of function:

```{r}
print("Hello, world")

str_c("Hello, world")
str_c("Hello, world", sep = "", collapse = NULL)
writeLines(str_c("Hello, world", sep = "", collapse = NULL))
```

</details>

<br>
<details><summary>**Step 2**: Create the function</summary>

```{r}
# Define function called `print_hello()`
print_hello <- function() {  # This function takes no arguments
  "Hello, world"             # The body of the function simply prints "Hello!"
}

# Call function
print_hello()

# Investigate return value
print_hello() %>% str()
```

1. __Function name__
    - Function name is `print_hello()`
2. __Function arguments__ (sometimes called "inputs")
    - `print_hello()` function doesn't take any arguments
3. __Function body__ (what the function does to the inputs)
    - Body of `print_hello()` simply prints "Hello, world"
    - **Return value**: The character value, `"Hello, world!"`

</details>

<br>

__Task__: Modify `print_hello()` to take a name as input and print `"Hello, world. My name is <name>"`

```{r, echo=-c(1:2)}
print_hello <- function(x) {
  str_c("Hello, world. My name is", x, sep = " ", collapse = NULL)
}

# Expected output
print_hello("Ozan Jaquette")
```

<details><summary>**Step 1**: Perform task outside of function</summary>

Say we want to print `"Hello, world. My name is Ozan Jaquette"`:

```{r}
"Hello, world. My name is Ozan Jaquette"
```

Remember that we eventually want the name to be an input to our function, so let's create a separate object, `x`, to store name:

```{r}
x <- "Ozan Jaquette"
str_c("Hello, world. My name is", x, sep = " ", collapse = NULL)
```

</details>

<br>
<details><summary>**Step 2**: Modify the function</summary>

```{r}
# Modify `print_hello()` function 
print_hello <- function(x) {  # This function takes 1 argument
  # In the body, use `str_c()` to concatenate greeting and name
  str_c("Hello, world. My name is", x, sep = " ", collapse = NULL)  
}

# Call function
print_hello(x = "Ozan Jaquette")
print_hello("Ozan Jaquette")


# Investigate return value
print_hello(x = "Ozan Jaquette") %>% str()
```

1. __Function name__
    - Function name is `print_hello()`
2. __Function arguments__ (sometimes called "inputs")
    - `print_hello()` function takes a name as input
3. __Function body__ (what the function does to the inputs)
    - Body of `print_hello()` prints `"Hello, world. My name is <name>"`
    - **Return value**: The character value, `"Hello, world. My name is <name>"`

</details>

<br>

__Task__: Modify `print_hello()` to take a name and birthdate as inputs and print `"Hello, world. My name is <name> and I am <age> years old"`

```{r, echo=-c(1:2)}
print_hello <- function(x, y) {
  age <- floor(as.numeric(as.duration(today() - mdy(y)), "years"))
  str_c("Hello, world. My name is", x, "and I am", age, "years old", sep = " ", collapse = NULL)
}

# Expected output
print_hello("Ozan Jaquette", "01/16/1979")
```

<details><summary>**Step 1**: Perform task outside of function</summary>

Use `mdy()` from the `lubridate` package to help handle birthdates:

```{r}
y <- "01/16/1979"
y
y %>% str()

mdy(y)
mdy(y) %>% str()
```

<br>
Using `today()` to get today's date, we can calculate an age given a birthdate:

```{r}
today()

# Calculate difference
today() - mdy(y)
str(today() - mdy(y))

# Convert to duration
as.duration(today() - mdy(y))
as.duration(today() - mdy(y)) %>% str()

# Create age in years as numeric vector
as.numeric(as.duration(today() - mdy(y)), "years")
as.numeric(as.duration(today() - mdy(y)), "years") %>% str()

floor(as.numeric(as.duration(today() - mdy(y)), "years"))

str(floor(as.numeric(as.duration(today() - mdy(y)), "years")))
```

<br>
Putting it all together, let's print the name and age in years:

```{r}
x <- "Ozan Jaquette"
y <- "01/16/1979"

age <- floor(as.numeric(as.duration(today() - mdy(y)), "years"))

str_c("Hello, world. My name is", x, "and I am", age, "years old", sep = " ", collapse = NULL)
```

</details>

<br>
<details><summary>**Step 2**: Modify the function</summary>

```{r}
# Modify `print_hello()` function 
print_hello <- function(x, y) {  # This function takes 2 arguments
  # In the body, calculate age
  age <- floor(as.numeric(as.duration(today() - mdy(y)), "years"))
  
  # Use `str_c()` to concatenate greeting, name, and age
  str_c("Hello, world. My name is", x, "and I am", age, "years old", sep = " ", collapse = NULL)
}

# Call function
print_hello(x = "Ozan Jaquette", y = "01/16/1979")
print_hello(x = "Kartal Jaquette", y = "01/24/1983")
print_hello(x = "Dan Jaquette", y = "10/29/1950")
print_hello(x = "Sumru Erkut", y = "06/15/1944")
print_hello(x = "Sumru Jaquette-Nasiali", y = "04/05/2019")

# Investigate return value
print_hello(x = "Ozan Jaquette", y = "01/16/1979") %>% str()
```

1. __Function name__
    - Function name is `print_hello`
2. __Function arguments__
    - `print_hello()` function takes a name and birthdate as inputs
3. __Function body__
    - Body of `print_hello()` prints `"Hello, world. My name is <name> and I am <age> years old"`
    - **Return value**: The character value, `"Hello, world. My name is <name> and I am <age> years old"`

</details>


<br>

__Task__: Test/break `print_hello()` by passing in birthdate using a different format

```{r, eval = FALSE, warning = FALSE}
print_hello(x = "Sumru Jaquette-Nasiali", y = "04/05/2019") # this works

print_hello(x = "Sumru Jaquette-Nasiali", y = "2019/04/05") # this does not
```

<br>
If we wanted to make additional improvements to `print_hello()`, we could modify the function to allow date of birth to be entered using several alternative formats (e.g., `"04/05/2019"` or `"2019/04/05"`). Alternatively, we could throw a custom error to warn users to use correct inputs ([see below](#checking-values)).


### `z_score()` function

The __z-score__ for an observation _i_ is the number of standard deviations away it is from the mean:

- $z_i = \frac{x_i - \bar{x}}{sd(x)}$

__Task__: Write function called `z_score()` that calculates the z-score for each element of a vector

```{r, echo=-c(1:2)}
z_score <- function(x) {
  (x - mean(x))/sd(x)
}

# Expected output
z_score(c(1, 2, 3, 4, 5))
```

<details><summary>**Step 1**: Perform task outside of function</summary>

Create a vector of numbers we'll use to calculate z-score:

```{r}
v <- c(1, 2, 3, 4, 5)
v

typeof(v)
class(v)
length(v)

v[1]  # 1st element of v
v[4]  # 4th element of v
```

<br>
We can calculate the z-score using the Base R `mean()` and `sd()` functions:

- $z_i = \frac{x_i - \bar{x}}{sd(x)}$

```{r}
mean(v)
sd(v)
```

<br>
Calculate z-score for some value:

```{r}
(1-mean(v))/sd(v)
(4-mean(v))/sd(v)
```

<br>
Calculate z-score for particular elements of vector `v`:

```{r}
v[1]
(v[1]-mean(v))/sd(v)

v[4]
(v[4]-mean(v))/sd(v)
```

<br>
Calculate `z_i` for all elements of vector `v`:

```{r}
v
(v-mean(v))/sd(v)
```

</details>

<br>
<details><summary>**Step 2**: Write the function</summary>

Write function to calculate z-score for all elements of the vector:

```{r}
z_score <- function(x) {
  (x - mean(x))/sd(x)
}
```

1. __Function name__
    - Function name is `z_score`
2. __Function arguments__
    - `z_score()` function takes an object `x` as input to calculate the z-score for
3. __Function body__
    - Body of `z_score()` calculates z-score of input (e.g., For each element of `x`, calculate difference between value of element and mean value of elements, then divide by standard deviation of elements)
    - **Return value**: A numeric vector containing z-scores calculated from input

<br>
Test/call the function:

```{r}
z_score(x = c(1, 2, 3, 4, 5))

  # investigate what function returns
  z_score(x = c(1, 2, 3, 4, 5)) %>% str()

v
z_score(x = v)

seq(20, 25)
z_score(x = seq(20, 25))

  #you could even create a new object whose values are the output/return of the function
  z_object <- z_score(x = c(1, 2, 3, 4, 5))
  z_object
  z_object %>% str()
```

</details>

<br><br>

__Task__: Improve the `z_score()` function by trying to break it

<details><summary>**Test 1**: Handling `NA` values</summary>

Let's see what happens when we try passing in a vector containing `NA` to our `z_score()` function:

```{r}
w <- c(NA, seq(1:5), NA)
w
z_score(x=w)

```

<br>
What went wrong? Let's revise our function to handle `NA` values:

```{r}
z_score <- function(x) {
  (x - mean(x, na.rm=TRUE))/sd(x, na.rm=TRUE)
}

w
z_score(w)
```

</details>

<br>
<details><summary>**Test 2**: Applying function to variables from a dataframe</summary>

Create dataframe called `df`:

```{r}
set.seed(12345) # set "seed" so we all get the same "random" numbers
df <- tibble(
  a = c(NA,rnorm(5)),
  b = c(NA,rnorm(5)),
  c = c(NA,rnorm(5))
)
class(df)
df

# subset a data frame w/ one element, using []
df["a"] 
str(df["a"])

# subset values of an element using [[]] or $
df[["a"]]
str(df[["a"]])

df$a
str(df$a)
```

<br>
Experiment with components of z-score, outside of a function:

```{r}
mean(df[["a"]], na.rm=TRUE)  # mean of variable "a"
sd(df[["a"]], na.rm=TRUE)  # std dev of variable "a"

mean(df$a, na.rm=TRUE)  # mean of variable "a"
sd(df$a, na.rm=TRUE)  # std dev of variable "a"

# Would these work?
  # mean(df["a"], na.rm=TRUE)  # mean of variable "a"
  # sd(df["a"], na.rm=TRUE)  # std dev of variable "a"

# Manually calculate z-score for second observation in variable "a"
df$a[2]
(df$a[2] - mean(df$a, na.rm=TRUE))/sd(df$a, na.rm=TRUE)

# Manually calculate z-score for all observations in variable "a"
df$a
df$a %>% length()
(df$a - mean(df$a, na.rm=TRUE))/sd(df$a, na.rm=TRUE)
```

<br>
Apply `z_score()` function to variables in dataframe:

```{r}
# z_score() function to calculate z-score for each obs of variable "a"
df$a
z_score(x = df$a)
z_score(x = df[["a"]])


# This approach doesn't work:
  # z_score(x = df["a"]) 
  # Why?:
    # df["a"] is a dataframe with one variable
    # you can't apply mean() or sd() functions to list/data frame object, only numeric atomic vector

# z-score for each obs of variable "b"
z_score(x = df[["b"]])

  # investigate the object returned by the function call
  z_score(x = df[["b"]]) %>% str()
  
  # could create a new object whose values are the output/return of the function
  z_object <- z_score(x = df[["b"]])
  z_object %>% str()
  
  # could even create new object that is a new variable in data frame
  df$b_z <- z_score(x = df[["b"]]) # same same
  
  df[["b_z"]] <- z_score(x = df[["b"]])
  
  
  df %>% glimpse()
  df$b_z %>% str()
  
  df$b_z <- NULL # delet variable b_z

```

</details>

<br><br>

__Task__: Use the `z_score()` function to create a new variable that is the z-score version of a variable

<details><summary>**Example 1**: Creating a new z-score variable for the `df` dataframe</summary>

First, briefly review how to create and delete variables using Base R approach:

```{r}
df

df$c_plus2 <- df$c + 2  # create variable equal to "c" plus 2
df

df$c_plus2 <- NULL  # remove variable "c_plus2"
df
```

<br>
Use `z_score()` function to create a new variable that equals the z-score of another variable. 

- Simply calling the `z_score()` function does not create a new variable:

```{r}
z_score(x = df$c)
df
```

<br>

- Instead of modifying the `z_score()` function so that the variable is assigned within the function, the preferred approach is to call the `z_score()` function after the assignment operator `<-`:

```{r}
df$c_z <- z_score(x = df$c)

# examine data frame
df
```

</details>

<br>
<details><summary>**Example 2**: Creating a new z-score variable for the recruiting dataset</summary>

We can apply our function to a "real" dataset too:

```{r}
#load dataset with one obs per recruiting event
load(url("https://github.com/anyone-can-cook/rclass2/raw/main/data/recruiting/recruit_event_somevars.RData"))

df_event_small <- df_event[1:10,] %>% # keep first 10 observations
  select(instnm,univ_id,event_type,med_inc) # keep 4 vars

df_event_small

#show observations for variable med_inc
df_event_small$med_inc

#calculate z-score of variable med_inc (without assignment)
z_score(x = df_event_small$med_inc)

#assign new variable equal to the z-score of med_inc
df_event_small$med_inc_z <- z_score(x = df_event_small$med_inc)

#inspect
df_event_small %>% head(5)
```

</details>

<br><br>

__Task__: Improve the `z_score()` function by first checking whether input `x` is valid

<details><summary>**Step 1**: Breaking current function with invalid input</summary>

Current function:

```{r}
z_score <- function(x) {
  (x - mean(x, na.rm=TRUE))/sd(x, na.rm=TRUE)
}
#?mean
#?sd
```

<br>
What kind of input is our current function limited to?

- `z_score()` function does simple arithmetic and utilizes the `mean()` and `sd()` functions
- `mean()` and `sd()` functions require `x` to be a numeric (or logical) atomic vector
  - `z_score()` function will break if the input `x` is not an atomic vector
  - `z_score()` function will break if the input `x` is not a numeric/logical atomic vector

```{r, eval=FALSE}
#function works on below numeric atomic vector

  str(df_event_small$med_inc)
  str(df_event_small[["med_inc"]]) # same same

#function doesn't work if input is a list/dataframe

  str(df_event_small["med_inc"]) # investigate object

  z_score(x = df_event_small["med_inc"]) # try applying z_score function to object

#function doesn't work if x is not a numeric vector
  str(df_event_small$instnm)
  
  z_score(x = df_event_small$instnm)
```

</details>

<br>
<details><summary>**Step 2**: Modify the function to handle invalid inputs</summary>

We could modify `z_score()` by using conditional statements to calculate the z-score only if input object `x` is the appropriate class of object:

```{r}
z_score <- function(x) {
  if (class(x) == "numeric" || class(x) == "logical") {
    (x - mean(x, na.rm=TRUE))/sd(x, na.rm=TRUE)
  }
}
```

<br>
We no longer run into errors if we supply an invalid input:

```{r}
# Test with list/dataframe input
str(df_event_small["med_inc"])

z_score(x = df_event_small["med_inc"])

  #investigate what this function call returns
  z_score(x = df_event_small["med_inc"]) %>% str()
  
# Test with character vector input
str(df_event_small$instnm)

z_score(x = df_event_small$instnm)

  #investigate what this function call returns
  z_score(x = df_event_small$instnm) %>% str()

```

<br>
Note that our function would return `NULL` if the input was invalid, so the new variable would not be created if we used `<-`:

```{r}
str(df_event_small$instnm)

# Invalid character vector input returns `NULL`
typeof(z_score(x = df_event_small$instnm))

# We would not see new variable/column `instnm_z`
df_event_small$instnm_z <- z_score(x = df_event_small$instnm)
df_event_small %>% head(5)
```

</details>
<br>

### Student exercise [OPTIONAL]

Some common tasks when working with survey data:

- Identify number of observations with `NA` values for a specific variable
- Identify number of observations with negative values for a specific variable
- Replace negative values with `NA` for a specific variable

<br>

#### `num_negative()` function

__Task__: Write function called `num_negative()`

- Write a function that counts the number of observations with negative values for a specific variable
- Apply this function to variables from dataframe `df` (created below)
- Adapted from Ben Skinner's _Programming 1_ R Workshop [HERE](https://www.btskinner.me/rworkshop/modules/programming_one.html)

```{r, echo=-c(1:3)}
set.seed(54321) # so that we all get the same random numbers
df <- tibble('id' = 1:100,
             'age' = sample(c(seq(11,20,1), -97,-98,-99),
                            size = 100,
                            replace = TRUE,
                            prob = c(rep(.09, 10), .1,.1,.1)),
             'sibage' = sample(c(seq(5,12,1), -97,-98,-99),
                               size = 100,
                               replace = TRUE,
                               prob = c(rep(.115, 8), .1,.1,.1)),
             'parage' = sample(c(seq(45,55,1), -4,-7,-8),
                               size = 100,
                               replace = TRUE,
                               prob = c(rep(.085, 11), .1,.1,.1))
)

# Sample dataframe `df` that contains some negative values
df
```

<br>
__Recommended steps__:

- Perform task outside of function
    - HINT: `sum(data_frame_name$var_name<0)`
- Write function
- Apply/test function on variables

<br>
<details><summary>**Step 1**: Perform task outside of function</summary>

```{r}
names(df) # identify variable names
df$age # print observations for a variable

#BaseR
sum(df$age<0) # count number of obs w/ negative values for variable "age"
```

</details>

<br>
<details><summary>**Step 2**: Write function</summary>

```{r}
num_missing <- function(x){
  sum(x<0)
}
```

</details>

<br>
<details><summary>**Step 3**: Apply function</summary>

```{r}
num_missing(df$age)
num_missing(df$sibage)
```

</details>
<br>

#### `num_missing()` function

In survey data, negative values often refer to reason for missing values:

- E.g., `-8` refers to "didn't take survey"
- E.g., `-7` refers to "took survey, but didn't answer this question"

__Task__: Write function called `num_negative()`

- Write a function that counts number of missing observations for a variable and allows you to specify which values are associated with missing for that variable. This function will take two arguments:
    - `x`: The variable (e.g., `df$sibage`)
    - `miss_vals`: Vector of values you want to associate with "missing" variable
        - Values to associate with missing for `df$age`: `-97,-98,-99`
        - Values to associate with missing for `df$sibage`: `-97,-98,-99`
        - Values to associate with missing for `df$parage`: `-4,-7,-8`

<br>
__Recommended steps__:

- Perform task outside of function
    - HINT: `sum(data_frame_name$var_name %in% c(-4,-5))`
- Write function
- Apply/test function on variables

<br>
<details><summary>**Step 1**: Perform task outside of function</summary>

```{r}
sum(df$age %in% c(-97,-98,-99))
```

</details>

<br>
<details><summary>**Step 2**: Write function</summary>

```{r}
num_missing <- function(x, miss_vals){

  sum(x %in% miss_vals)
}
```

</details>

<br>
<details><summary>**Step 3**: Apply function</summary>

```{r}
num_missing(df$age,c(-97,-98,-99))
num_missing(df$sibage,c(-97,-98,-99))
num_missing(df$parage,c(-4,-7,-8))
```

</details>
<br>

## Function arguments

### Default values

What are **default values** for arguments?

- The **default value** for an argument is the value that will be used if the argument value was not supplied during the function call
- When writing the function, you can specify the **default value** for an argument using `name=value`
- Most Base R functions and functions from other packages specify default values for one or more arguments

<br>

**Example**: `str_c()` function

The `str_c()` function has default values for `sep` and `collapse`:

- Syntax
  - `str_c(..., sep = "", collapse = NULL)`
- Arguments
  - `...`: One or more character vectors to join, separated by commas
  - `sep`: String to insert between input vectors
      - Default value: `sep = ""`
  - `collapse`: Optional string used to combine input vectors into single string
      - After joining vectors into single string within each element, should resulting elements be combined into a single string? If so, what string to insert between elements?
      - Default value: `collapse = NULL` is to not combine elements into a single string

```{r}
# We want to join the following two vectors element-wise into a single character vector
c("a","b")
c(1,2)

# manually specifying default values
str_c(c("a", "b"), c(1, 2), sep = "", collapse = NULL)

# If we don't specify `sep` and `collapse`, they take the default values
str_c(c("a", "b"), c(1, 2))

# specify value for `sep` that overrides default value
str_c(c("a", "b"), c(1, 2), sep = "~")
length(str_c(c("a", "b"), c(1, 2), sep = "~")) # resulting vector has length = 2

# specify value for `collapse` that overrides default
str_c(c("a", "b"), c(1, 2), collapse = "|")
length(str_c(c("a", "b"), c(1, 2), collapse = "|"))  # resulting vector has length = 1

# specify alternative values for both `sep` and `collapse`
  #str_c(c("a", "b"), c(1, 2), sep = "~", collapse = "|")
```

<br>
<details><summary>**Example**: Adding a default value to our `z_score()` function</summary>

Recall the `z_score()` function we developed previously, where we wrote this function to remove `NA` values prior to calculating z-score:

```{r}
z_score <- function(x) {
  (x - mean(x, na.rm=TRUE))/sd(x, na.rm=TRUE)
}

w <- c(NA, seq(1:5), NA)
w
z_score(w)
```


<br>
We could add an argument (named `na`) that specifies whether `NA`s should be removed prior to calculating z-scores:

```{r}
z_score <- function(x, na) {
  (x - mean(x, na.rm=na))/sd(x, na.rm=na)
}

w
z_score(x=w, na=TRUE)
z_score(x=w, na=FALSE)
#z_score(w) # error: argument "na" is missing, with no default
```

<br>
We could also add a default value for the `na` argument. Following conservative approach, we'll specify default value as `FALSE` which means that any `NA` values in input vector `x` will result in z-score of `NA` for all observations:

```{r}
z_score <- function(x, na = FALSE) {
  (x - mean(x, na.rm=na))/sd(x, na.rm=na)
}

w

z_score(x=w) # uses default value of FALSE
z_score(w, na= FALSE) # manually specify default value
z_score(w, na = TRUE) # override default value
```

</details>
<br>

### Dot-dot-dot (`...`)

Many functions take an **arbitrary number of arguments**, including:

- `select()`

    ```{r}
    #?select
    select(df_event,instnm,univ_id,event_type,med_inc) %>% names()
    ```

- `sum()`

    ```{r}
    #?sum
    sum(3,3,2,2,1,1)
    ```

- `str_c`

    ```{r}
    #?str_c
    
    # 1 character vector as input
    str_c(c("a", "b", "c"))
    
    # 2 character vectors as input
    str_c(c("a", "b", "c"), " is for ")
    
    # 3 character vectors as input
    str_c(c("a", "b", "c"), " is for ", c("apple", "banana", "coffee"))
    ```
    
<br>
All of these functions rely on a **special argument** `...` (pronounced "dot-dot-dot")  

- Dot-dot-dot (`...`) allows a function to take an arbitrary number of arguments
- Wickham and Grolemund [chapter 19.5.3](https://r4ds.had.co.nz/functions.html#dot-dot-dot) states:

  > "`...` captures any number of arguments that aren’t otherwise matched."

<br>
When writing functions, there are **two primary uses** of including `...` arguments:

1. A means of allowing the function to take an arbitrary number of arguments, as in the `select()` and `sum()` functions
1. When we write our own function with the special argument `...`, we can pass those inputs into another function that takes `...` (e.g., `str_c()`)

<br>

<details><summary>**Example**: Adding dot-dot-dot (`...`) as function argument</summary>


Recall the first iteration of our `print_hello()` function, which basically just printed a name that we specified in function call. Let's modify the function to make it take an arbitrary number of names to greet:

- Function that only took one argument

    ```{r}
    # Define function
    print_hello1 <- function(x) {  
      str_c("Hello ", x, "!") 
    }
    
    # Call function
    print_hello1(x="Ozan")
    ```

- Modify function to take an arbitrary number of names to greet

    ```{r}
    # Define function
    print_hello2 <- function(...) {  # The function accepts an arbitrary number of inputs
      str_c("Hello ", str_c(..., sep = ", "), "!")  # Pass the `...` to `str_c()`
    }
    
    # Call function
    print_hello2("Dasher", "Dancer", "Prancer", "Vixen")

    ```

</details>

### Checking values

How to handle **invalid inputs**?

- As seen previously in the [`z_score()` example](#z_score-function), one way to check for invalid inputs is using conditional statements
- "It's good practice to check important preconditions, and throw an error (with `stop()`), if they are not true" ([R for Data Science](https://r4ds.had.co.nz/functions.html#checking-values))
    - Especially in the case where the invalid input does not cause the function to break, but gives an unintended output instead, we want to explicitly raise an error so this does not go unnoticed

<br>
__`stop()` function__ (base R):

- The `stop()` function "stops execution of the current expression and executes an error action"

```{r, eval=FALSE}
?stop

# SYNTAX AND DEFAULT VALUES
stop(..., call. = TRUE, domain = NULL)
```

<br>
<details><summary>**Example**: Using `stop()` to check invalid name input to `print_hello()` function</summary>

Recall the original `print_hello()` function. It will not print a greeting if `NA` is supplied as the input:

```{r}
print_hello <- function(x) {
  str_c("Hello, world. My name is", x, sep = " ", collapse = NULL)
}

print_hello("ozan")
print_hello(NA)
```

<br>
We can raise an error with a custom message if the input is `NA`:

```{r, eval=FALSE}
print_hello <- function(x) {
  if (is.na(x)) {
    stop("`x` must not be `NA`")
  }
  
  str_c("Hello, world. My name is", x, sep = " ", collapse = NULL)
}

print_hello(x="ozan")
print_hello(x=NA)
```

</details>
<br>

<details><summary>**Example**: Using `stop()` to check invalid date input to `print_hello()` function</summary>

Recall the version of `print_hello()` function that prints both the user's name and age. It will not work properly if the birthdate input is not supplied in month-day-year format:

```{r}
print_hello <- function(x, y) {
  age <- floor(as.numeric(as.duration(today() - mdy(y)), "years"))
  
  str_c("Hello, world. My name is", x, "and I am", age, "years old", sep = " ", collapse = NULL)
}

print_hello(x = "Sumru Jaquette-Nasiali", y="04/05/2019") # this works

print_hello(x = "Sumru Jaquette-Nasiali", y="2019/04/05") # this does not
```

<br>
We can raise an error with a custom message if the birthdate is not in the right format:

```{r, eval=FALSE}
print_hello <- function(x, y) {
  if (is.na(mdy(y))) {
    stop("`y` must be in month-day-year format")
  }
  
  age <- floor(as.numeric(as.duration(today() - mdy(y)), "years"))
  
  str_c("Hello, world. My name is", x, "and I am", age, "years old", sep = " ", collapse = NULL)
}

print_hello(x = "Sumru Jaquette-Nasiali", y = "04/05/2019")
print_hello(x = "Sumru Jaquette-Nasiali", y = "2019/04/05")
```

<br>
We can also add the check for the name input as well:

```{r, eval=FALSE}
print_hello <- function(x, y) {
  # Check name input `x`
  if (is.na(x)) {
    stop("`x` must not be `NA`")
  }
  
  # Check birthdate input `y`
  if (is.na(mdy(y))) {
    stop("`y` must be in month-day-year format")
  }
  
  age <- floor(as.numeric(as.duration(today() - mdy(y)), "years"))
  
  str_c("Hello, world. My name is", x, "and I am", age, "years old", sep = " ", collapse = NULL)
}
```

</details>
<br>

## Return values

Recall that functions generally follow **three sequential steps**:

1. Take in __input__ object(s)
2. __Process__ the input
3. __Return__ a new object, which may be a vector, data-frame, plot, etc.

### Implicit returns

What are **return values**?

- Just as functions can take inputs (i.e., arguments), functions can also return values as output
- The last statement that the function evaluates will be automatically (i.e., implicitly) returned
  - e.g., so if you want a function to return a data frame named `df`, you could have the last line of the function be this:
    - `df`
- We can use the assignment operator `<-` to store returned values in a new object for future use


Recall the `print_hello()` function:

```{r}
# Define function
print_hello <- function() {
  "Hello!"  # The last statement in the function is returned
}

# Call function
print_hello() %>% str()
h <- print_hello()  # We can show that `print_hello()` returns a value by storing it in `h`
h                   # `h` stores the value "Hello!"
```

### Explicit returns

How can we **explicitly return values** from the function?

- We can use `return()` to explicitly return a value from our function
- This is commonly used when we want to return from the function early (e.g., inside an `if` block)
- There can be multiple `return()` in a function
- Returning from a function means exiting the function, so no other code below the point of return would be run

Recall the `print_hello()` function:

```{r}
# Define function
print_hello <- function() {
  return("Hello!")   # Explicitly return "Hello!"
  print("Goodbye!")  # Since this is after `return()`, it never gets run
}

# Call function
print_hello()
h <- print_hello()  # `print_hello()` returns "Hello!"
h
```

<br>
<details><summary>**Example**: Writing a function with multiple returns</summary>

Recall the previous example where we assess the prices of diamonds from the `diamonds` dataset from `ggplot2`. Let's move the `if`/`else if`/`else` blocks inside of a function, then call the function from inside the loop.

As seen below, the last statement that the function evaluates (i.e., whichever `if`/`else if`/`else` block is run) will be implicitly returned:

```{r}
assess_price <- function(price) {
  if (price < 500) {
    str_c("This diamond costs $", price, " and is affordable.")
  } else if (price < 1000) {
    str_c("This diamond costs $", price, " and is pricey...")
  } else {
    str_c("This diamond costs $", price, " and is too expensive!")
  }
}

assess_price(price=450)
assess_price(price=1050) %>% str()

prices <- unique(diamonds$price)[23:27]
prices
for (i in prices) {
  writeLines(assess_price(i))
}
```

<br>
But if we were to have another line after the conditional part, then that would be implicitly returned instead, since it is now the last statement in the function:

```{r}
assess_price <- function(price) {
  if (price < 500) {
    str_c("This diamond costs $", price, " and is affordable.")
  } else if (price < 1000) {
    str_c("This diamond costs $", price, " and is pricey...")
  } else {
    str_c("This diamond costs $", price, " and is too expensive!")
  }
  
  "I can't afford that."  # This is now the last statement in the function that will be returned
}

for (i in prices) {
  writeLines(assess_price(i))
}
```

<br>
We can use `return()` to explicitly return early from the function:

```{r}
assess_price <- function(price) {
  if (price < 500) {
    return(str_c("This diamond costs $", price, " and is affordable."))  # Return early
  } else if (price < 1000) {
    return(str_c("This diamond costs $", price, " and is pricey..."))  # Return early
  } else {
    writeLines(str_c("This diamond costs $", price, " and is too expensive!"))
  }
  
  "I can't afford that."
}

for (i in prices) {
  writeLines(assess_price(i))
}

```

</details>

### Returning multiple values

How can we return **multiple values** from a function?

- R can only return 1 value or object from a function
- To return multiple values, one workaround is to create a list containing these items and return the list

<br>
<details><summary>**Example**: Returning multiple values from a function using a list</summary>

Let's say we have the following function that filters the `diamonds` dataset by color, then generates some information on multiple characteristics (i.e., `cut` and `clarity`). For now, it is printing a frequency table for each characteristic to the screen:

```{r}
diamond_info_by_color <- function(color) {
  df <- diamonds %>% filter(color == color)
  
  print(table(df$cut))
  print(table(df$clarity))
}

diamond_info_by_color(color = 'E')
diamond_info_by_color('E') %>% str() # what is returned
```

<br>
If we want to return the frequency tables from the function (i.e., return multiple objects), we can do so by combining them together into a single list and returning that list:

```{r}
diamond_info_by_color <- function(color) {
  df <- diamonds %>% filter(color == color)
  
  list(cut_table = table(df$cut), clarity_table = table(df$clarity))  # implicitly return list
}

diamond_info_by_color('E')
diamond_info_by_color('E') %>% str()
```

<br>
We can then store the returned list in an object using `<-`, and access the individual elements within the list using `[[]]` or `$`:

```{r}
# Store returned list in `info`
info <- diamond_info_by_color('E')

info %>% str()

# Access individual elements of the list
info[['cut_table']]


# Can also store individual elements in new objects
clarity_table <- info$clarity_table
clarity_table
```

</details>

### Pipeable functions

What are **pipeable functions**?

- **Pipeable functions** return an object that is of the same type as the first argument it accepts
- This allow us to chain functions that accept/return objects of the same type using pipes (`%>%`)
  - E.g., The `filter()` and `select()` functions from `tidyverse` both accept a dataframe as the first argument and return a modified dataframe, so they can be chained together
    
    ```r
    df %>% filter(...) %>% select(...)
    ```

Wickham distinguishes between **2 types** of pipeable functions ([Chapter 19.6.2](https://r4ds.had.co.nz/functions.html#writing-pipeable-functions))

- **Transformation**: Function modifies the first argument that is passed in and returns that
  - E.g., `filter()` or `select()` functions from `tidyverse`
- **Side-effects**: Function does not modify the first argument
  - E.g., Functions that "performs an action on the object, like drawing a plot or saving a file"
  - The first argument should still be returned from these functions so that they remain pipeable


<br>
<details><summary>**Example**: Writing a pipeable function</summary>

Pipeable functions do not only work with dataframes, but with any objects like an atomic vector. For example:

```{r}
vec <- c(1, 2, 3, 4)
vec


#  These functions accept a vector as the first argument, modify it, then return it
add_two <- function(v) {
  v + 2
}

vec
add_two(v=vec)
vec %>% add_two() # same


times_three <- function(v) {
  v * 3
}

vec
times_three(v=vec)
vec %>% times_three() # same
```

<br>
We can chain together the functions to perform the operations in order:

```{r}
vec
vec %>% add_two()
vec %>% add_two() %>% times_three()

vec
vec %>% times_three()
vec %>% times_three() %>% add_two()
```

</details>

<br>

# What to learn next

<br>

**Writing functions and loops that utilize tidyverse functions**

- Including certain `Tidyverse`/`dplyr` functions in a user-written function requires some programming concepts that we did not introduce in this lecture
  - For more explanation, see [here](https://www.r-bloggers.com/data-frame-columns-as-arguments-to-dplyr-functions/) and [here](https://adv-r.hadley.nz/quasiquotation.html#unquoting). 
- For a pretty digestable explanation of how to write user-defined functions that utilzie tidyverse functions, read the [Programming with dplyr](https://dplyr.tidyverse.org/articles/programming.html) vignette

<br>
<br>

**Replacing loops with "map" functions from the `purrr` package and/or "apply" functions from Base R**

> The pattern of looping over a vector, doing something to each element and saving the results is so common that the purrr package provides a family of functions to do it for you ([Wickham, chapter 21.5](https://r4ds.had.co.nz/iteration.html#the-map-functions))

- The `purrr` package, which is part of Tidyverse, creates a family of functions called "map" functions replace the need for writing loops
- to learn more about `purrr` map functions, read section [21.4](https://r4ds.had.co.nz/iteration.html#for-loops-vs.-functionals) and section [21.5](https://r4ds.had.co.nz/iteration.html#the-map-functions) of _R for Data Science_ by Wickham 
- `purrr` map functions are similar to the "apply family of functions" from Base R
  - check out this [tutorial](https://www.datacamp.com/tutorial/r-tutorial-apply-family) on apply functions